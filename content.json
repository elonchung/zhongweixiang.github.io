{"pages":[{"title":"","date":"2018-05-04T05:28:24.736Z","updated":"2018-05-04T05:28:24.736Z","comments":true,"path":"baidu_verify_uyVqI5LhhO.html","permalink":"https://www.elonchung.cn/baidu_verify_uyVqI5LhhO.html","excerpt":"","text":"uyVqI5LhhO"},{"title":"","date":"2018-05-04T01:19:58.687Z","updated":"2018-05-04T01:19:58.687Z","comments":true,"path":"google5f8a468f4a1f027b.html","permalink":"https://www.elonchung.cn/google5f8a468f4a1f027b.html","excerpt":"","text":"google-site-verification: google5f8a468f4a1f027b.html"},{"title":"404 Not Found：该页无法显示","date":"2018-05-02T15:40:57.985Z","updated":"2018-05-02T15:40:57.985Z","comments":false,"path":"/404.html","permalink":"https://www.elonchung.cn//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-05-03T11:48:31.394Z","updated":"2018-05-03T11:48:31.394Z","comments":false,"path":"books/index.html","permalink":"https://www.elonchung.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-03T11:48:31.394Z","updated":"2018-05-03T11:48:31.394Z","comments":false,"path":"categories/index.html","permalink":"https://www.elonchung.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-05-03T11:48:31.394Z","updated":"2018-05-03T11:48:31.394Z","comments":false,"path":"repository/index.html","permalink":"https://www.elonchung.cn/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-05-03T11:48:31.394Z","updated":"2018-05-03T11:48:31.394Z","comments":true,"path":"links/index.html","permalink":"https://www.elonchung.cn/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-03T11:48:31.394Z","updated":"2018-05-03T11:48:31.394Z","comments":false,"path":"tags/index.html","permalink":"https://www.elonchung.cn/tags/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2017-06-27T11:19:14.000Z","updated":"2020-05-05T09:57:27.168Z","comments":false,"path":"about/index.html","permalink":"https://www.elonchung.cn/about/index.html","excerpt":"","text":"个人信息姓名：Elon Chung邮件：elonchung@163.com2018-2020的学习内容深度：前端：Nodejs、HTML5、vuejs、Angularjs后端：JAVA基础、JAVA底层原理、JAVA框架使用、PHP底层原理、PHP扩展、设计模式、算法、Sockect数据库：MongoDB、PostgreSQL、ElasticSearch架构：高并发、高可用、分布式架构、集群（redis、mysql）广度：前端：Nodejs、HTML5、vuejs、Angularjs后端：Java基本应用、Python爬虫、Web端与自动化方向开发架构：分布式架构、微服务、大数据、区块链一个小小的码农，有个小小的3年计划：熟悉热门的web全栈的知识。"}],"posts":[{"title":"Java商城开发相关技术和模块设计","slug":"mall-dev","date":"2020-06-28T05:10:09.000Z","updated":"2020-08-11T13:12:49.801Z","comments":true,"path":"2020/06/mall-dev/","link":"","permalink":"https://www.elonchung.cn/2020/06/mall-dev/","excerpt":"","text":"Java商城开发相关技术和模块设计框架选择 springcloud alibaba注册中心consulconfiggateway dubbosecurity缓存redis事务使用seatarabbitmq定时任务quartz整合springboot -adminORM mybatis-plus统一错误处理、日志aopcanal同步数据elk搜索logback.xml公共方法mall结构商城商品模块商品展示、分类购物车优惠券商品抢购订单模块物流模块支付模块评论模块用户中心管理中心商品商品发布管理商品分类管理sku管理商品属性管理价格管理订单管理发货退货单据查询 报表物流信息管理用户权限控制用户角色用户用户权限-模块用户权限-模块操作节点运营管理广告展示抢购设置首页设置网站基础配置","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://www.elonchung.cn/categories/学习资料/"}],"tags":[{"name":"资料","slug":"资料","permalink":"https://www.elonchung.cn/tags/资料/"}]},{"title":"Java商城订单设计","slug":"mall-order","date":"2020-06-28T05:10:09.000Z","updated":"2020-08-11T13:13:02.296Z","comments":true,"path":"2020/06/mall-order/","link":"","permalink":"https://www.elonchung.cn/2020/06/mall-order/","excerpt":"","text":"12345678910111213141516171819/** * 生成18位订单编号:8位日期+2位平台号码+2位支付方式+6位以上自增id */private String generateOrderSn(OmsOrder order) &#123; StringBuilder sb = new StringBuilder(); String date = new SimpleDateFormat(\"yyyyMMdd\").format(new Date()); String key = REDIS_DATABASE+\":\"+ REDIS_KEY_ORDER_ID + date; Long increment = redisService.incr(key, 1); sb.append(date); sb.append(String.format(\"%02d\", order.getSourceType())); sb.append(String.format(\"%02d\", order.getPayType())); String incrementStr = increment.toString(); if (incrementStr.length() &lt;= 6) &#123; sb.append(String.format(\"%06d\", increment)); &#125; else &#123; sb.append(incrementStr); &#125; return sb.toString();&#125;订单下单流程获取购物车信息生成下单的商品信息（不同商品有不同信息）判断购物车中商品是否库存充足是否使用活动优惠或优惠券（全场通用，指定分类，指定商品） 优惠券处理算出相应金额积分使用规则算出最终实付金额进行锁定库存根据商品合计、运费、活动优惠、优惠券、积分计算应付金额订单状态，收货人信息、使用优惠，积分，设置自动收货天数等转化为订单信息并插入数据库 主订单和订单详情表后续相关操作：修改优惠券，积分计算，删除购物车，发送延迟消息（什么时候超时取消订单）消息队列超时支付订单取消 或 订单取消修改订单状态为交易取消解除订单商品库存锁定修改优惠券使用状态返还使用积分开发阶段初期开发，主体框架完善，基本增删改查，严谨地方（金额，抢购）等把控好。用户量达到瓶颈，优化代码，考虑加缓存，扩容服务器，备份服务器，负载均衡等单机优化，JVM优化，数据库慢查询优化，加载时间要求阈值多线程最多的场景：web服务器本身；各种专用服务器（如游戏服务器）；多线程的常见应用场景：1、后台任务，例如：定时向大量（100w以上）的用户发送邮件；2、异步处理，例如：发微博、记录日志等；3、分布式计算#####ThreadLocal是一种多线程间并发访问变量的解决方案。与synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而使用了以空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全，因此它不是一种数据共享的解决方案。","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://www.elonchung.cn/categories/学习资料/"}],"tags":[{"name":"资料","slug":"资料","permalink":"https://www.elonchung.cn/tags/资料/"}]},{"title":"IDEA插件easyCode  mybatis-plus宏","slug":"easycode-mybatis-plus","date":"2020-05-15T09:24:45.365Z","updated":"2020-07-07T01:43:14.727Z","comments":true,"path":"2020/05/easycode-mybatis-plus/","link":"","permalink":"https://www.elonchung.cn/2020/05/easycode-mybatis-plus/","excerpt":"","text":"IDEA插件easyCode mybatis-plus宏entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960##导入宏定义$!define$!init##保存文件（宏定义）#save(\"/entity\", \".java\")##包路径（宏定义）#setPackageSuffix(\"entity\")##自动导入包（全局变量）$!autoImportimport com.baomidou.mybatisplus.extension.activerecord.Model;import java.io.Serializable;##拿到主键#if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0))#end##表注释（宏定义）#tableComment(\"表实体类\")@SuppressWarnings(\"serial\")@Data@TableName(\"`$!&#123;tableInfo.obj.name&#125;`\")public class $!&#123;tableInfo.name&#125; extends Model&lt;$!&#123;tableInfo.name&#125;&gt; &#123; private static final long serialVersionUID = $!tool.serial();#foreach($column in $tableInfo.fullColumn) #if($&#123;column.comment&#125;)/** * $&#123;column.comment&#125; */#end #if($&#123;column.name&#125;==\"createTime\") @ApiModelProperty(value = \"创建时间\", example = \"2020-05-01 11:28:26\") @JsonFormat(shape = JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd HH:mm:ss\") @TableField(fill = FieldFill.INSERT)#elseif($&#123;column.name&#125;==\"updateTime\") @ApiModelProperty(value = \"修改时间\", example = \"2020-05-01 11:28:26\") @JsonFormat(shape = JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd HH:mm:ss\") @TableField(fill = FieldFill.INSERT_UPDATE)#elseif($&#123;pk.name&#125;==$&#123;column.name&#125;) @TableId(value = \"$&#123;column.name&#125;\", type = IdType.AUTO) @ApiModelProperty( name =\"$!&#123;column.name&#125;\", value=\"$column.comment\")#else @ApiModelProperty( name =\"$!&#123;column.name&#125;\", value=\"$column.comment\")#end private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;#end#foreach($column in $tableInfo.pkColumn) /** * 获取主键值 * * @return 主键值 */ @Override protected Serializable pkVal() &#123; return this.$!column.name; &#125; #break#end&#125;mapper123456789101112131415161718192021##导入宏定义$!define$!init##设置表后缀（宏定义）#setTableSuffix(\"Mapper\")##保存文件（宏定义）#save(\"/Mapper\", \"Mapper.java\")##包路径（宏定义）#setPackageSuffix(\"mapper\")import com.baomidou.mybatisplus.core.mapper.BaseMapper;import $!&#123;tableInfo.savePackageName&#125;.entity.$!tableInfo.name;##表注释（宏定义）#tableComment(\"表数据库访问层\")public interface $!&#123;tableName&#125; extends BaseMapper&lt;$!tableInfo.name&gt; &#123;&#125;service1234567891011121314151617181920##导入宏定义$!define$!init##设置表后缀（宏定义）#setTableSuffix(\"Service\")##保存文件（宏定义）#save(\"/service\", \"Service.java\")##包路径（宏定义）#setPackageSuffix(\"service\")import com.baomidou.mybatisplus.extension.service.IService;import $!&#123;tableInfo.savePackageName&#125;.entity.$!tableInfo.name;##表注释（宏定义）#tableComment(\"表服务接口\")public interface $!&#123;tableName&#125; extends IService&lt;$!tableInfo.name&gt; &#123;&#125;impl.xml123456789101112131415161718192021222324##导入宏定义$!define$!init##设置表后缀（宏定义）#setTableSuffix(\"ServiceImpl\")##保存文件（宏定义）#save(\"/service/impl\", \"ServiceImpl.java\")##包路径（宏定义）#setPackageSuffix(\"service.impl\")import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;import org.springframework.stereotype.Service;##表注释（宏定义）#tableComment(\"表服务实现类\")@Service(\"$!tool.firstLowerCase($tableInfo.name)Service\")public class $!&#123;tableName&#125; extends ServiceImpl&lt;$!&#123;tableInfo.name&#125;Mapper, $!&#123;tableInfo.name&#125;&gt; implements $!&#123;tableInfo.name&#125;Service &#123;&#125;controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103##导入宏定义$!init$!define##设置表后缀（宏定义）#setTableSuffix(\"Controller\")##保存文件（宏定义）#save(\"/controller\", \"Controller.java\")##包路径（宏定义）#setPackageSuffix(\"controller\")##定义服务名#set($serviceName = $!tool.append($!tool.firstLowerCase($!tableInfo.name), \"Service\"))##定义实体对象名#set($entityName = $!tool.firstLowerCase($!tableInfo.name))import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.api.ApiController;import com.baomidou.mybatisplus.extension.api.R;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import $!&#123;tableInfo.savePackageName&#125;.entity.$!tableInfo.name;import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.io.Serializable;import java.util.List;##表注释（宏定义）#tableComment(\"表控制层\")@RestController@RequestMapping(\"$!tool.firstLowerCase($!tableInfo.name)\")@Api(tags = \"$!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)\") public class $!&#123;tableName&#125; extends ApiController &#123; /** * 服务对象 */ @Resource private $!&#123;tableInfo.name&#125;Service $!&#123;serviceName&#125;; /** * 分页查询所有数据 * * @param page 分页对象 * @param $!entityName 查询实体 * @return 所有数据 */ @GetMapping(\"findAll\") @ApiOperation(value = \"分页查询所有数据 $!&#123;tableInfo.comment&#125;\") public R selectAll(Page&lt;$!tableInfo.name&gt; page, $!tableInfo.name $!entityName) &#123; return success(this.$!&#123;serviceName&#125;.page(page, new QueryWrapper&lt;&gt;($!entityName))); &#125; /** * 通过主键查询单条数据 * * @param id 主键 * @return 单条数据 */ @GetMapping(\"getOne/&#123;id&#125;\") @ApiOperation(value = \"通过主键查询单条数据 $!&#123;tableInfo.comment&#125;\") public R selectOne(@PathVariable Integer id) &#123; return success(this.$!&#123;serviceName&#125;.getById(id)); &#125; /** * 新增数据 * * @param $!entityName 实体对象 * @return 新增结果 */ @PostMapping(\"insert\") @ApiOperation(value = \"新增数据 $!&#123;tableInfo.comment&#125;\") public R insert(@RequestBody $!tableInfo.name $!entityName) &#123; return success(this.$!&#123;serviceName&#125;.save($!entityName)); &#125; /** * 修改数据 * * @param $!entityName 实体对象 * @return 修改结果 */ @PutMapping(\"update\") @ApiOperation(value = \"修改数据 $!&#123;tableInfo.comment&#125;\") public R update(@RequestBody $!tableInfo.name $!entityName) &#123; return success(this.$!&#123;serviceName&#125;.updateById($!entityName)); &#125; /** * 删除数据 * * @param idList 主键结合 * @return 删除结果 */ @DeleteMapping(\"delete\") public R delete(@RequestParam(\"idList\") List&lt;Long&gt; idList) &#123; return success(this.$!&#123;serviceName&#125;.removeByIds(idList)); &#125;&#125;mapper.xml1234567891011121314$!init##引入mybatis支持$!mybatisSupport##设置保存名称与保存位置$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, \"Mapper.xml\"))$!callback.setSavePath($tool.append($modulePath, \"/src/main/resources/mapper\"))&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper\"&gt;&lt;/mapper&gt;","categories":[],"tags":[]},{"title":"常用Maven包 -- pom.xml","slug":"maven-pom","date":"2020-04-23T01:51:34.684Z","updated":"2020-08-11T12:25:00.522Z","comments":true,"path":"2020/04/maven-pom/","link":"","permalink":"https://www.elonchung.cn/2020/04/maven-pom/","excerpt":"","text":"Maven – pom.xml打包相关插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;properties&gt; &lt;maven.build.timestamp.format&gt;yyyy-MM-dd&lt;/maven.build.timestamp.format&gt; &lt;project.jar.output.directory&gt; G:\\packages &lt;/project.jar.output.directory&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;!--用于启动 springboot 插件 ！！！！！试了下，不能和下面插件共存--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--用于跳过测试test插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--用于把包打到指定目录插件 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven进行package的时候执行--&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;!--jar包保存位置 --&gt; &lt;copy todir=\"$&#123;project.jar.output.directory&#125;$&#123;maven.build.timestamp&#125;\"&gt; &lt;!--antrun自动生成的配置文件的保存位置，这里默认是父项目的target文件夹 --&gt; &lt;fileset dir=\"$&#123;project.build.directory&#125;\"&gt; &lt;include name=\"*.jar\" /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[],"tags":[]},{"title":"docker 安装elk6.7.0","slug":"docker-elk6.7.0","date":"2020-03-10T05:21:52.000Z","updated":"2020-08-11T12:35:43.387Z","comments":true,"path":"2020/03/docker-elk6.7.0/","link":"","permalink":"https://www.elonchung.cn/2020/03/docker-elk6.7.0/","excerpt":"","text":"docker 安装elk6.7.0 logstash实现自动同步增量数据拉取容器并安装sebp/elk:6701docker run -it --privileged=true -p 5601:5601 -p 9200:9200 -p 5044:5044 -p 9300:9300 -v /opt/elasticsearch/elk-data:/var/lib/elasticsearch/data -v /opt/elasticsearch/plugins:/opt/elasticsearch/plugins -v /opt/elasticsearch/logstash:/opt/logstash/config/config-mysql --name elk7 sebp/elk:6701cd /opt/elasticsearch/logstash/config/config-mysql进入配置目录下载mysql-connector-java-5.1.46.jar新建goods.conf 和 goods_increment.conf全量配置goods.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950input &#123; jdbc &#123; jdbc_connection_string =&gt; \"jdbc:mysql://172.17.0.1:3306/wl-produce-mall?characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true\" jdbc_user =&gt; \"wltest\" jdbc_password =&gt; \"wltest\" #此处的路径最好是绝对路径，行对路径取决与允许命令的目录 jdbc_driver_library =&gt; \"../config/config-mysql/mysql-connector-java-5.1.46.jar\" jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\" jdbc_default_timezone =&gt;\"Asia/Shanghai\" jdbc_paging_enabled =&gt; \"true\" jdbc_page_size =&gt; \"50000\" #此处的路径最好是绝对路径，行对路径取决与允许命令的目录 #statement =&gt; \"SELECT * FROM wp_goods WHERE goods_status in (4,6) AND last_update_time &gt; :sql_last_value AND last_update_time &lt; NOW() ORDER BY last_update_time DESC\" statement =&gt; \"select * from wp_goods where goods_status in (4,6) \" #statement =&gt; \"SELECT * FROM wp_goods WHERE goods_status IN (4,6) AND last_update_time &gt; UNIX_TIMESTAMP( :sql_last_value )*1000 AND last_update_time &lt; UNIX_TIMESTAMP(NOW())*1000 ORDER BY last_update_time DESC\" #use_column_value =&gt; \"true\" #tracking_column =&gt; \"last_update_time\" #tracking_column_type =&gt; \"numeric\" #tracking_column_type =&gt; \"timestamp\" #record_last_run =&gt; \"true\" #last_run_metadata_path =&gt; \"/opt/elk/other/config-mysql/lastquery\" clean_run =&gt; \"true\" #statement_filepath =&gt; \"/opt/elk/other/config-mysql/exec.sql\"# schedule =&gt; \"*/5 * * * * *\" schedule =&gt; \"*/2 * * * * *\" type =&gt; \"goods\" &#125;&#125;output &#123; #设置窗口日志输出 stdout &#123; codec =&gt; json_lines &#125; if [type] == \"goods\" &#123; elasticsearch &#123; hosts =&gt; [\"localhost:9200\"] #注意index的值不支持大写字母 index =&gt; \"goods\" #document_type自行设置，不设置时，默认为doc #document_type =&gt; \"goods2\" #此处的值来自查询sql中的列名称，根据需要自行配置 document_id =&gt; \"%&#123;id&#125;\" &#125; &#125;&#125;自增配置goods_increment.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748input &#123; jdbc &#123; jdbc_connection_string =&gt; \"jdbc:mysql://172.17.0.1:3306/wl-produce-mall?characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true\" jdbc_user =&gt; \"wltest\" jdbc_password =&gt; \"wltest\" #此处的路径最好是绝对路径，行对路径取决与允许命令的目录 jdbc_driver_library =&gt; \"../config/config-mysql/mysql-connector-java-5.1.46.jar\" jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\" jdbc_default_timezone =&gt; \"Asia/Shanghai\" jdbc_paging_enabled =&gt; \"true\" jdbc_page_size =&gt; \"50000\" #此处的路径最好是绝对路径，行对路径取决与允许命令的目录 #statement =&gt; \"SELECT * FROM wp_goods WHERE goods_status in (4,6) AND last_update_time &gt; :sql_last_value AND last_update_time &lt; NOW() ORDER BY last_update_time DESC\" #statement =&gt; \"select * from wp_goods where goods_status in (4,6) \" statement =&gt; \"SELECT * FROM wp_goods WHERE goods_status IN (4,5,6,7) AND last_update_time &gt; UNIX_TIMESTAMP( :sql_last_value )*1000 AND last_update_time &lt; UNIX_TIMESTAMP(NOW())*1000 ORDER BY last_update_time DESC\" #use_column_value =&gt; \"true\" # tracking_column =&gt; \"last_update_time\" # tracking_column_type =&gt; \"numeric\" #tracking_column_type =&gt; \"timestamp\" #record_last_run =&gt; \"true\" #last_run_metadata_path =&gt; \"/opt/elk/other/config-mysql/lastquery\" clean_run =&gt; \"false\" #statement_filepath =&gt; \"/opt/elk/other/config-mysql/exec.sql\" # schedule =&gt; \"* * * * *\" schedule =&gt; \"*/5 * * * * *\" type =&gt; \"goods\" &#125;&#125;output &#123; #设置窗口日志输出 stdout &#123; codec =&gt; json_lines &#125; if [type] == \"goods\" &#123; elasticsearch &#123; hosts =&gt; [\"localhost:9200\"] #注意index的值不支持大写字母 index =&gt; \"goods\" #document_type自行设置，不设置时，默认为doc #document_type =&gt; \"goods\" #此处的值来自查询sql中的列名称，根据需要自行配置 document_id =&gt; \"%&#123;id&#125;\" &#125; &#125;&#125;注意坑：在容器中如果访问宿主ip数据库使用：172.17.0.1 172.17.0.2先执行goods.conf导入所有商品数据123456789101112131415161718192021222324252627命令：docker ps -a 进入容器：docker exec -it 容器id或名称 /bin/bashcd /opt/logstash/bin./logstash -f ../config/config-mysql/goods.conf 成功后 ctrl+c 停止nohub ./logstash -f ../config/config-mysql/goods_increment.conf &gt;/dev/null &amp;如果已经有执行的logstash任务可以加一个参数：--path.data=/config/config-mysql查看日志tailf /opt/elasticsearch/logstash/conf/nohup.out# 安装参数# 单例-e \"discovery.type=single-node\"# 启动的内存设置-e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" # 单独安装Esdocker run -it -d --privileged=true -p 9200:9200 -p 9300:9300 -v /opt/elasticsearch/elk-data:/var/lib/elasticsearch/data -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" --name elk670 elasticsearch:6.7.012345678910111213141516171819202122232425262728指定单个字段查询AND OR 可切换POST /nba/_search&#123; &quot;query&quot;: &#123; &quot;query_string&quot;: &#123; &quot;default_field&quot;: &quot;displayNameEn&quot;, &quot;query&quot;: &quot;james OR harden&quot; &#125; &#125;, &quot;size&quot;: 100&#125;指定多个字段查询POST /nba/_search&#123; &quot;query&quot;: &#123; &quot;query_string&quot;: &#123; &quot;fields&quot;: [ &quot;displayNameEn&quot;, &quot;teamNameEn&quot; ], &quot;query&quot;: &quot;James AND Rockets&quot; &#125; &#125;, &quot;size&quot;: 100&#125;","categories":[{"name":"Docker","slug":"Docker","permalink":"https://www.elonchung.cn/categories/Docker/"},{"name":"ES","slug":"Docker/ES","permalink":"https://www.elonchung.cn/categories/Docker/ES/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.elonchung.cn/tags/Docker/"},{"name":"ES","slug":"ES","permalink":"https://www.elonchung.cn/tags/ES/"}]},{"title":"docker 学习","slug":"docker","date":"2020-03-02T05:21:52.000Z","updated":"2020-08-11T12:20:41.315Z","comments":true,"path":"2020/03/docker/","link":"","permalink":"https://www.elonchung.cn/2020/03/docker/","excerpt":"","text":"docker 学习数据卷 /数据挂载多容器可以共用同一个宿主挂载的目录使用方式1. 直接 -v 主机目录:容器数据目录 2. docker inspect id 查看挂载 mounts[] docker run -it –name 子容器 –volumes-from 父容器 镜像安装 软件12345678910111213141516171819# docker命令参数说明--restart always 随着docker启动而软件自动启动 -d 后台保护进程启动-p 端口映射--name 容器名-e 其他配置-v 挂载目录exec -it 容器名 /bin/bash 进入容器# 安装 RocketMQdocker run -d -p 9876:9876 -v /d/develop/rocketmq/data/namesrv/logs:/root/logs -v /d/develop/rocketmq/data/namesrv/store:/root/store --name rmqnamesrv -e \"MAX_POSSIBLE_HEAP=100000000\" rocketmqinc/rocketmq sh mqnamesrvdocker run -d -p 10911:10911 -p 10909:10909 -v /d/develop/rocketmq/data/broker/logs:/root/logs -v /d/develop/rocketmq/data/broker/store:/root/store --name rmqbroker --link rmqnamesrv:namesrv -e \"NAMESRV_ADDR=namesrv:9876\" rocketmqinc/rocketmq sh mqbroker -c ../conf/broker.confdocker run -e \"JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false\" -p 8282:8080 -t styletang/rocketmq-console-ng#安装rabbitmqdocker run -d --restart always --name rabbitmq3.7.26 -p 5672:5672 -p 15672:15672 -v /d/docker/rabbitmq/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost --restart=always -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin 37ed13330d04安装mysql同步canal123456789101112#安装mysql同步canaldocker network create --subnet=172.18.0.0/24 mynetwork--net mynetwork --ip 172.18.0.2docker run -p 11111:11111 --name canal-2 -d canal/canal-server:v1.1.4 -v /d/develop/canal/conf:/home/admin/canal-server/confdocker run -d --restart always --privileged=true --net mynetwork --ip 172.18.0.8 -v /d/develop/docker/mysql/my.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /d/develop/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name mysql57 mysql:5.7.30docker exec -it canal-server bashtailf -100 canal-server/logs/example/example.log1234[mysqld]log-bin=mysql-bin # 开启binlogbinlog-format=ROW # 选择ROW模式server_id=1 # 配置MySQL replaction需要定义，不要和Canal的slaveId重复1234567891011# 创建账号CREATE USER canal IDENTIFIED BY &apos;canal&apos;; # 授予权限GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;canal&apos;@&apos;%&apos;;-- GRANT ALL PRIVILEGES ON *.* TO &apos;canal&apos;@&apos;%&apos; ;# 刷新并应用FLUSH PRIVILEGES;show variables like &apos;log_bin&apos;;show variables like &apos;binlog_format&apos;;show master status;参考：https://www.cnblogs.com/1124li/p/11713757.html","categories":[{"name":"Docker","slug":"Docker","permalink":"https://www.elonchung.cn/categories/Docker/"},{"name":"ES","slug":"Docker/ES","permalink":"https://www.elonchung.cn/categories/Docker/ES/"},{"name":"Canal","slug":"Docker/ES/Canal","permalink":"https://www.elonchung.cn/categories/Docker/ES/Canal/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.elonchung.cn/tags/Docker/"},{"name":"ES","slug":"ES","permalink":"https://www.elonchung.cn/tags/ES/"},{"name":"Canal","slug":"Canal","permalink":"https://www.elonchung.cn/tags/Canal/"}]},{"title":"mybatis-开启懒加载","slug":"mybatis-开启懒加载","date":"2019-12-09T11:31:23.000Z","updated":"2020-08-11T12:40:22.255Z","comments":true,"path":"2019/12/mybatis-开启懒加载/","link":"","permalink":"https://www.elonchung.cn/2019/12/mybatis-开启懒加载/","excerpt":"","text":"mybatis-开启懒加载123#配置mybatis-plus.configuration.lazy-loading-enabled=true #开启懒加载mybatis-plus.configuration.aggressive-lazy-loading=false #需要时加载Mybatis懒加载报错末尾显示_$$_jvst12a_0[“handler”])的解决方案返回的类加上注解（即实体类） 此种方法比较方便@JsonIgnoreProperties(value = { “handler” })解决方法关闭该查询的懒加载 fetchType=“eager”配置json转换器属性SerializationFeature.FAIL_ON_EMPTY_BEANS为false","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://www.elonchung.cn/tags/mybatis/"}]},{"title":"rockectMQ安装、启动","slug":"serverCommand","date":"2019-11-02T05:21:52.000Z","updated":"2020-08-11T12:56:17.782Z","comments":true,"path":"2019/11/serverCommand/","link":"","permalink":"https://www.elonchung.cn/2019/11/serverCommand/","excerpt":"","text":"123456789101112131415 cd www/server/rocketmq-all-4.7.0-bin-release/bin# 启动mqnamesrv nohup mqnamesrv 1&gt;/www/server/rocketmq-all-4.7.0-bin-release/logs/ng.log 2&gt;/www/server/rocketmq-all-4.7.0-bin-release/logs/ng-err.log &amp;#启动mqbrokernohup mqbroker &gt;/www/server/rocketmq-all-4.7.0-bin-release/logs/mq.log &amp;#启动mqbroker 8088nohup java -jar /www/server/rocketmq-console-ng-1.0.1.jar &amp;#防火墙firewall-cmd --zone=public --add-port=8088/tcp --permanent firewall-cmd --reload参考：https://www.cnblogs.com/jing99/p/13166602.html","categories":[{"name":"rockectMQ","slug":"rockectMQ","permalink":"https://www.elonchung.cn/categories/rockectMQ/"}],"tags":[{"name":"rockectMQ","slug":"rockectMQ","permalink":"https://www.elonchung.cn/tags/rockectMQ/"}]},{"title":"微信支付","slug":"wxpay","date":"2019-08-15T08:54:28.000Z","updated":"2020-08-11T12:44:50.274Z","comments":true,"path":"2019/08/wxpay/","link":"","permalink":"https://www.elonchung.cn/2019/08/wxpay/","excerpt":"","text":"微信支付接口方式： JSAPI 、付款码、NATIVE、APP支付、H5支付、小程序支付、刷脸支付JSAPI支付：应用场景：商户已有H5商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。公众号上设置支付目录设置：商户最后请求拉起微信支付收银台的页面地址我们称之为“支付目录”，商户实际的支付目录必须和在微信支付商户平台设置的一致，否则会报错“当前页面的URL未注册“支付授权目录设置登录微信支付商户平台（pay.weixin.qq.com）–&gt;产品中心–&gt;开发配置，设置后一般5分钟内生效。支付授权目录校验规则说明：1、如果支付授权目录设置为顶级域名（例如：https://www.weixin.com/ ），那么只校验顶级域名，不校验后缀；2、如果支付授权目录设置为多级目录，就会进行全匹配，例如设置支付授权目录为https://www.weixin.com/abc/123/，则实际请求页面目录不能为https://www.weixin.com/abc/，也不能为https://www.weixin.com/abc/123/pay/，必须为https://www.weixin.com/abc/123/设置授权域名、主要获取openid的域名商户号上设置设置支付秘钥（自己生成md5串）设置证书（退款需要）业务流程图appid 服务商 APPIDmch_id 微信支付分配的商户号sub_appid分账 – 双向证书作者：梁川链接：https://www.zhihu.com/question/48909315/answer/136528033来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。我理解题主指的APP平台不只是APP，还包括B2B的商城管理系统，以实现商家入驻对管理上架商品。如果是这样，那么两种模式都可以支持。最核心的问题是：B2B的商城管理系统是否支持商家配置自己的微信支付/支付宝的商户号、支付密钥等信息，商家是否愿意把支付密钥等私密信息配置到一个第三方平台（类似很多微信商城管理系统的做法）。1、模式1如果APP支持商家通过商城管理系统配置自己的商户号、支付密钥等信息，用户购买商品时候商城平台使用对应商户的商户号、支付密钥发起支付请求，微信支付/支付宝直接将资金结算给商家对公户，资金不过平台。由于平台本身有订单信息，因此可以根据对应的订单信息计算出对应的佣金，与商户对账后，由商家把佣金通过企业网银、第三方支付代付等方式转账给平台。2、模式2此种模式比较典型，也是美团、饿了么之类的互联网电商平台的通用做法。此种模式下，用户购买商品时，发起支付请求使用的商户号、支付密钥是平台的，微信支付/支付宝将资金结算给平台对公户，然后由平台按照结算周期将资金结算给商户。题主后面的问题是结算款项代付问题。代付的方式有很多，依赖于诸多因素，例如：1、代付渠道：例如个人网银、超级网银、结算中心、央行大小额、银企直连等2、本行/跨行3、对公/对私4、代付金额：大于5万，小于五万等等5、时效性：实时、2小时、次日到账6、单笔/批量以上各种因素都会影响代付的成本，可以根据自己需要对比选择合适的方案。","categories":[{"name":"WeChat","slug":"WeChat","permalink":"https://www.elonchung.cn/categories/WeChat/"}],"tags":[{"name":"WeChat","slug":"WeChat","permalink":"https://www.elonchung.cn/tags/WeChat/"}]},{"title":"微信公众号H5与小程序开发及区别","slug":"H5vsMicro","date":"2019-08-15T00:49:53.000Z","updated":"2020-08-11T12:57:35.491Z","comments":true,"path":"2019/08/H5vsMicro/","link":"","permalink":"https://www.elonchung.cn/2019/08/H5vsMicro/","excerpt":"","text":"微信公众号H5与小程序开发及区别主要区别：小程序不支持关注、推送消息，只能用户触发，开发成本低，营销推广方式多，营销工具也比较多，用户体验更好。应用入口小程序：公众号菜单，二维码，小程序搜索，桌面快捷方式服务号：公众号菜单，二维码消息通知小程序：当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发3条，多次支付下发条数独立，互相不影响）；服务号：可以无限制使用调用系统蓝牙小程序：可以直接调用系统蓝牙服务号：需要接入微信硬件平台后台存活小程序：可在后台存活服务号：不可以用户体验小程序：无需刷新即时通信，可本地缓存服务号：每次打开请求一次服务器，延时较大开发成本小程序：微信官方封装了很多接口，减少开发成本服务号：接口自己完成，成本相对高些微信小程序和微信公众号有什么区别和联系?1、微信小程序是什么?一句话解释：微信小程序是运行在微信里的APP2、微信小程序的流量入口?截至2017年10月1日，微信小程序主要的流量入口，点击图片，查看大图3、微信小程序的核心优势· 快微信小程序无需下载，即开即用· 广微信小程序入口极多，线下覆盖范围与应用场景非常广· 强微信小程序可实现的能力几乎比拟APP· 通与公众号可以互补打通，提升用户好感和黏度4、微信小程序与公众号的区别与关系小程序与公众号绝非替代关系，而是互补关系，而且未来会代替功能单一的垂直APP5、微信小程序能为企业解决的问题· 打通线上线下企业以自身(营业执照注册地址)为中心，扩散至半径5km可见，用户以自身(当前实际地理位置)为中心，可见半径5km的所有小程序(此距离并非固定，随时可能调整)· 优质传播渠道仅以呼和浩特距离，半径5km大约覆盖人口130万，如果以传统广告方式传播，费用可谓巨大，而使用微信小程序，费用只需千分之一。· 与公众号打通小程序与公众号又是同级产品，又是能力的互相延伸。公众号可以在底部菜单、发文插入等多种方式引导用户使用小程序。· 提升品牌力与销售额优质的传播渠道+流量的导入，企业可以有效的利用这一渠道和其优势，推广产品 / 服务，获得销售额与品牌力、知名度的双重提升。6、半径5km可见，是一个什么概念?以呼和浩特市区举例，市区人口近220万(玉泉区，赛罕区，新城区，回民区)市区行政面积大约是东西13公里，南北9公里(总面积约130平方公里)而半径5km的概念是78.5平方公里即约3/5行政面积与人口约有130万人(微信用户)可以看到企业的小程序7、如何开始制作微信小程序A 自行开发可以自主设计，功能自行开发门槛较高，需要编程如委托开发，费用在数万至数十万间B 使用微信小程序制作精灵开发操作简单，易于上手模板丰富，无需编程永久免费模板，高级模板最高数千元一年，功能以垂直行业划分","categories":[{"name":"WeChat","slug":"WeChat","permalink":"https://www.elonchung.cn/categories/WeChat/"}],"tags":[{"name":"WeChat","slug":"WeChat","permalink":"https://www.elonchung.cn/tags/WeChat/"}]},{"title":"windows操作集","slug":"windows","date":"2019-08-14T08:54:28.000Z","updated":"2020-08-11T12:45:17.757Z","comments":true,"path":"2019/08/windows/","link":"","permalink":"https://www.elonchung.cn/2019/08/windows/","excerpt":"","text":"关闭hypervisor docker需要开启auto，虚拟机需要关闭offbcdedit /set hypervisorlaunchtype off修改cmd为管理员 新建reg 复制以下内容后保存双击运行123[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers]\"c:\\\\windows\\\\system32\\\\cmd.exe\"=\"~ RUNASADMIN\"you-get 视频下载12345678// 安装及下载命令 需先安装Pythonpip3 install you-getpip3 install --upgrade you-getyou-get --playlist 'https://www.youtube.com/watch?v=jNQXAC9IVRw'// --playlist 列表下载// -i 查看下载格式// --format=flv 清晰度格式下载 最好选默认// -o d:/xx 下载路径","categories":[{"name":"Windows","slug":"Windows","permalink":"https://www.elonchung.cn/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.elonchung.cn/tags/Windows/"}]},{"title":"微服务技术框架生态","slug":"micro-service","date":"2019-07-10T05:21:52.000Z","updated":"2020-08-11T12:50:59.730Z","comments":true,"path":"2019/07/micro-service/","link":"","permalink":"https://www.elonchung.cn/2019/07/micro-service/","excerpt":"","text":"了解微服务什么是微服务为什么出现微服务微服务解决问题微服务技术框架生态微服务框架DubboSpring CloudSpring Cloud AlibabaDubbo是个微服务整体架构的框架，提供的功能包括服务注册发现，远程调用，监控等等。对标的项目是Spring Cloud。但Spring Cloud是一个系列的软件，有很多组件来拼装提供微服务的总体架构。Dubbo自己全封装了。注册中心EurekaConsulZookeeper网关Dubbogateway熔断 路由Zuul Ribbon FeignHystrix","categories":[{"name":"Micro-server","slug":"Micro-server","permalink":"https://www.elonchung.cn/categories/Micro-server/"}],"tags":[{"name":"Micro-server","slug":"Micro-server","permalink":"https://www.elonchung.cn/tags/Micro-server/"}]},{"title":"Spring-IOC原理","slug":"spring-ioc原理","date":"2018-10-15T05:21:52.000Z","updated":"2020-08-11T12:49:29.453Z","comments":true,"path":"2018/10/spring-ioc原理/","link":"","permalink":"https://www.elonchung.cn/2018/10/spring-ioc原理/","excerpt":"","text":"Spring-IOC原理控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。**IOC本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。例子原本使用MySQL，那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .那我们如何去解决呢 ?我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125;现在去我们的测试类里 , 进行测试 ;123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125;大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.elonchung.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.elonchung.cn/tags/Spring/"}]},{"title":"PHP架构师之路-提高阶段","slug":"improve","date":"2018-06-02T05:21:52.000Z","updated":"2018-06-02T09:05:32.937Z","comments":true,"path":"2018/06/improve/","link":"","permalink":"https://www.elonchung.cn/2018/06/improve/","excerpt":"","text":"PHP架构师之路-提高阶段（2-3年）重点玩转LNMP搭建和配置，精通各种大流量高并发场景的中型PHP系统的开发目标能够独立完成LNMP环境的搭建，根据项目需要熟练进行各种常规配置；有能力定位和解决大部分开发和线上问题；有能力独立完成一个中型系统的架构设计，具备一定的团队领导力，能够带领10人以内的小团队完成一个中型系统的开发，能够独立完成一个大型系统的模块架构和开发工作知识点Linux：能够流畅的使用Shell脚本来完成很多自动化的工作；awk/sed/perl也操作的不错，能够完成很多文本处理和数计等工作；了解基本的Linux服务，知道如何查看Linux的性能指标数据，知道基本的Linux下面的问题跟踪等。Nginx：了解复杂一些的Nginx配置；包括多核配置、events、proxy_pass,sendfile/tcp_*配置，知道超时等相关配置对性能的影响；知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx配置调优；知道基本的nginx运行原理（master/worker机制，epoll），知道为什么nginx性能比apache性能好等知识；MySQL/MongoDB：掌握一些常规SQL优化技巧（group by/order by/rand优化等）；能够冷热备份MySQL数据，知道影响innodb/myisam性能的配置选项，知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如知道如何搭建mysql主从同步的环境，知道各个binlog_format的区别；知道MySQL的性能追查，包括slow_log/explain等，还知道基本的索引建立处理等知识；原理方面了解基本的MySQL的架构（Server+存储引擎），知道基本的【nnoDB/MyISAM索引存储结构和不同（聚簇索引，B树）；知道基本的InnoDB事务处理机制；了解大部分MySQL异常情况的处理方案。条件允许的情况，建议了解一下NoSQL的代表MongoDB数据库，顺便对比与MySQL的差别，同时能够在合适的应用场景安全谨慎的使用MongoDB，知道基本的PHP+MongoDB的结合开发。Redis/Memcached：在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道Memcached和Redis的异同和应用场景，能够独立安装Redis/Memcached，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；了解Redis基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等。原理部分，能够大概了解Memcached的内存结构（slab机制），了解Redis常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等，顺便了解一下Redis的事务、RDB、AOF等机制更好PHP能够随意安装PHP和各种第三方扩展的编译安装配置；了解php-fpm的大部分配置选项和含义（如max_requests/max_children/request_terminate_timeout之类的影响性能的配置），知道mod_php/fastcgi的区别；对PHP面向对象有深入的理解，了解SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过一个以上常见PHP MVC框架的代码，知道基本PHP框架内部实现机制和设计思想；在PHP开发中已经能够熟练使用常规的设计模式来进行开发（抽象工厂/单例/观察者/命令链/策略/适配器等模式）；建议开发自己的PHPMVC框架来充分让开发自由化，让自己深入理解MVC模式，也让自己能够在业务项目开发里快速升级；熟悉PHP的各种代码优化方法，熟悉大部分PHP安全方面问题的解决处理；熟悉基本的PHP执行的机制原理（Zend引擎/扩展基本工作机制）C/C++：开始涉猎一定的C/C++语言，能够写基本的C/C++代码，对基本的C/C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对Linux下面的C语言开发有基本的了解概念，会简单的makefile文件编写，能够使用简单的GCC/GDB的程序编译简单调试工作；对基本的网络编程有大概了解前端：熟悉基本的HTTP协议（协议代码200/300/400/500，基本的HTTP交互头）；条件允许，可以在深入写出稍微优雅的HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/Bootstrap之类）；如果条件允许，可以深入学习JavaScript编程，比如闭包机制、DOM处理；再深入些可以读读jQuery源码做深入学习。（本项不做重点学习，除非对前端有兴趣）系统架构设计：能够设计大部分中型系统的网站架构、数据库、基本PHP框架选型；性能测试排查处理等；能够完成类似：浏览器-&gt;CDN（Squid）-&gt;Nginx+PHP-&gt;缓存-&gt;数据库结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作；","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"}]},{"title":"PHP架构师之路-基础阶段","slug":"junior","date":"2018-06-02T05:21:52.000Z","updated":"2018-06-02T09:09:33.560Z","comments":true,"path":"2018/06/junior/","link":"","permalink":"https://www.elonchung.cn/2018/06/junior/","excerpt":"","text":"PHP架构师之路-基础阶段（1-2年）重点LNMP基本操作与配置，PHP基础开发能力目标从按照Linux服务器，搭建LNMP环境，到建起一个简单的PHP站点，都能独立完成；能够独立开发一个中型PHP系统的功能模块知识点Linux：基本的Linux命令（查找、检索、编辑文件，tail查看日志），能写简单的shell脚本、awk/sed脚本命令等Nginx：从源码编译安装，核心配置，能够让Nginx+php-fpm正常工作MySQL：从源码编译安装，基本的命令行操作MySQL（不要依赖工具），知道InnoDB/MyISAM的区别，知道如何选择引擎和编码PHP：系统的学习一遍PHP本身，熟悉和使用各种MySQL链接库API（mysqli、PDO等），至少熟练掌握一种主流的PHP框架（ThinkPHP、Yii、Laravel等），了解基本MVC运行机制，了解一些主流PHP框架之间的区别前端：适当学习下HTML/CSS/JS等相关知识，能够写一些基本的JavaScript脚本，能够看懂别人写的前端代码，能够修改一些简单的功能系统架构设计：能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器-&gt;Nginx+PHP-&gt;数据库架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"}]},{"title":"PHP架构师之路-长期持续","slug":"target","date":"2018-06-02T05:21:52.000Z","updated":"2018-06-02T09:11:57.191Z","comments":true,"path":"2018/06/target/","link":"","permalink":"https://www.elonchung.cn/2018/06/target/","excerpt":"","text":"PHP架构师之路–长期持续重点LNMP系统架构能力，至少选择一个领域彻底深入进去，同时尽力拓宽知识面，为架构和技术决策提高眼界能够独立完成各种LNMP系统的架构工作，能够在某个领域Hold住全场，能够解决该领域各种复杂问题，提供较为专业的技术支持和决策目标能够独立完成各种LNMP系统的架构工作，能够在某个领域Hold住全场，能够解决该领域各种复杂问题，提供较为专业的技术支持和决策知识点Linux能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar等）能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、监控等工作；对awk/sed/perl等应用已经如火纯青，能够随意操作控制处理文本，统计分析各种复杂格式的数据；对Linux内部机制有一些了解，对内核模块加载、启动错误等等有个基本的处理；同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等；Nginx能够把Nginx操作的很熟练，能够对Nginx进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于Nginx工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的master/worker工作机制，Nginx内部的事件处理，内存管理等等；同时可以学习Nginx扩展的开发，可以定制一些自己私有的扩展；同时可以对Nginx+Lua有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对Nginx原理的深入理解，可以考虑成为Nginx方向的深入专业者。MySQL\\MongoDB能够完成一些复杂操作，比如大批量数据的导入导出，线上超大表的表结构更改或者增删索引字段等高危操作；能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等）、连接池软件选择应用，对show*（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL备份技术的深入熟悉，包括灾备还原、对Binlog的深入理解，冷热备份，多IDC备份等；在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）源码的学习理解，如果条件允许，可以参考CSV引擎开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展.MongoDB层面，可以考虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制Redis/Memcached建议阅读Memcached的源码，特别是内存管理部分，方便深入理解；Redis部分，可以多做一些复杂的数据结构的应用（zset来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及aof等同步机制的学习应用，设计一个高可用的Redis应用架构和集群；建议可以深入的学习一下Redis的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读和充分学习一下包括核心事件管理、内存管理、内部核心数据结构等。如果兴趣允许，可以成为一个Redis方面非常专业的使用者。MySQL\\MongoDB：能够完成一些复杂操作，比如大批量数据的导入导出，线上超大表的表结构更改或者增删索引字段等高危操作；能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等）、连接池软件选择应用，对show*（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL备份技术的深入熟悉，包括灾备还原、对Binlog的深入理解，冷热备份，多IDC备份等；在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）源码的学习理解，如果条件允许，可以参考CSV引擎开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展.MongoDB层面，可以考虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制PHP：从基本代码应用上面来说，能够解决在PHP开发中遇到95%的问题，了解大部分PHP的技巧；对大部分的PHP框架能够迅速在一天内上手使用，并且了解各个主流PHP框架的优缺点，能够迅速为新项目做技术选型；在配置方面，了解一些比较偏门的配置选项（php auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理；对php的工作机制比较了解，包括php-fpm工作机制，对zend引擎有基本熟悉（vm/gc/stream处理），阅读过基本的PHP内核源码，对PHP内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的PHP扩展开发，了解一些扩展开发的中高级知识（minit/rinit等），熟悉php跟apache/nginx不同的通信交互方式细节（mod_php/fastcgi）C/C++：除了第二阶段的基础C/C++语法和数据结构，进一步学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree等）；熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络IO模型的差别和选型，熟悉不同异步网络IO模型的原理和差异（select/poll/epoll/iocp等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker等）；了解大部分C/C++后端Server开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct/http/thirft/protobuf等）；能够很熟练的使用GCC和GDB来开发编译调试程序，能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追bug；前端：深入了解HTTP协议（包括各个细致协议特殊协议代码和背后原因，比如302静态文件缓存了，502是nginx后面php挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，可以自己开发一些类似jQuery的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验JavaScript功力；其他开发语言：建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby之类的，函数式编程语言可以试试Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试Java/Golang，数据统计分析可以了解了解R语言，如果想换个视角做后端业务，可以试试Node.js还有前面提到的跟Nginx结合的Nginx_Lua等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang的解决方案简单的惊人；比如在不想选择C/C++的情况下，还有类似高效的Erlang/Golang可用等等；主要是提升视野。其他专业方向：看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），人工智能和机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。系统架构设计：能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似浏览器-&gt;CDN-&gt;负载均衡-&gt;接入层-&gt;Nginx+PHP-&gt;业务缓存-&gt;数据库-&gt;各路复杂后端RPC交互（存储后端、逻辑后端、反作弊后端、外部服务）-&gt;更多后端这样的复杂系统；能够支撑每天数千万到数亿流量网站的正常开发维护工作。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"}]},{"title":"编写简单的爬虫架构","slug":"python-spider","date":"2018-05-21T05:21:52.000Z","updated":"2018-05-21T05:08:38.093Z","comments":true,"path":"2018/05/python-spider/","link":"","permalink":"https://www.elonchung.cn/2018/05/python-spider/","excerpt":"","text":"hupuNBA-spider此项目为简单的爬虫架构spider_main.py 爬虫调度程序url_manager.py url管理器html_downloader.py html下载器html_parser.py html解析器html_outputer.py html输出器架构流程项目GitHub链接","categories":[{"name":"Python","slug":"Python","permalink":"https://www.elonchung.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.elonchung.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.elonchung.cn/tags/爬虫/"}]},{"title":"网站优化所有问题 一（持续更新中）","slug":"site-optimize","date":"2018-05-06T01:31:05.000Z","updated":"2018-05-06T09:36:38.089Z","comments":true,"path":"2018/05/site-optimize/","link":"","permalink":"https://www.elonchung.cn/2018/05/site-optimize/","excerpt":"","text":"网站优化所有问题 一（持续更新中）以下是通过dareboost网站进行质量和性能报告问题具体有几类：浏览器呈现缓存策略合规数据量请求数质量SEO安全jQuery的Keep-Alive已启用 （已解决）Keep-alive允许使用相同的TCP连接发送和接收多个请求（在HTTP 1.1中默认激活）。启用压缩功能（已解决）当 PageSpeed Insights 检测到以下情形时，就会触发此规则：所提供的资源是可压缩的，但未进行 gzip 压缩。概览所有现代浏览器都支持 gzip 压缩并会为所有 HTTP 请求自动协商此类压缩。启用 gzip 压缩可大幅缩减所传输的响应的大小（最多可缩减 90%），从而显著缩短下载相应资源所需的时间、减少客户端的流量消耗并加快网页的首次呈现速度。 要了解详情，请参阅使用 GZIP 压缩文本。建议在您的网络服务器上启用并测试 gzip 压缩支持。HTML5 Boilerplate 项目包含所有最热门服务器的示例配置文件，以及对每个配置标记和每项设置的详细注解：请在列表中查找您喜爱的服务器，并找到 gzip 部分，然后确认您已使用推荐的设置配置了您的服务器。 或者，您也可查看您的网络服务器的文档以了解如何启用压缩功能：Apache：使用 mod_deflateNginx：使用 ngx_http_gzip_module此页面暴露于“clickjacking”类型的攻击 （已解决）让恶意的人不要将您的网页集成到他们的网站中。点击劫持解释当您的网页通过&lt;frame>或&lt;iframe>标记与恶意网站集成时，就会发生这种攻击。通过这样做，攻击者可以说服用户，当他们不在时，他们在自己的页面上。毫无戒心的用户可能会输入个人信息，这些信息在恶意网站上可见并因此易受攻击。为了避免这种情况，请始终指明哪些域有权整合您的网页。如何防止点击劫持？配置一个“X-Frame-Options”HTTP标头。配置您的服务器，使主资源响应包含“X-Frame-Options”HTTP标头。可以定义三个值：DENY 防止任何框架或iframe集成页面;SAMEORIGIN 仅授权来自相同域名的帧;ALLOW-FROM uri指示允许将页面集成到框架中的域（但与某些浏览器不兼容）此页面上未配置“X-Frame-Options”HTTP标头; 你更有可能遭受点击劫持。指定一个字符集（已解决）以下资源的HTTP标头中没有指定字符集。在HTTP标题中指定字符集可以加快浏览器呈现速度。指定Content-TypeHTTP标头中使用的字符集可让浏览器立即解析页面。解决问题：在标签上添加alt属性（已解决）alt属性是SEO的重要标准。事实上，搜索引擎爬虫不能分析图形内容。这就是为什么他们使用替代文字来返回一致的结果，就像在Google图片中一样。1&lt;img src =“product.jpg”alt =“我的产品说明” /&gt;该alt属性用于几个与搜索引擎优化无关的情况：当屏幕阅读器用于辅助功能时;图像加载时，特别是对于慢速连接;未找到图像文件时。如果没有什么东西适合描述图像，则可以设置一个空文本。我们建议您确保大部分图片定义相关文字。阅读W3C的建议。解决问题：所有图片标签添加alt属性1&lt;img class =“img-circle img-rotate” src =“/images/xxx.png” width=“200” height=“200” alt=&quot;xxxx&quot; /&gt;重定向需要551毫秒 （未解决）重定向会触发网络上的可避免往返行为并增加页面加载时间。HTTP重定向问题HTTP重定向允许指定从不同的URL访问所需的内容。它们触发一个新的HTTP请求来检索目标资源并返回一个介于300和399之间的HTTP代码。请参阅 HTTP重定向的规范。重定向太长而无法访问正确的内容原因：http 80 强制转https 443图像在浏览器端调整大小（未解决）图像不得大于实际显示的大小，以避免加载不必要的数据。调整图像大小解释不建议在浏览器端调整图像大小以减少渲染大小。例如，如果您的图像设置为在特定页面上以300px×300px呈现，请不要将1000px版本的原始图像上传到您的页面。相反，调整/裁剪图像以适应显示尺寸，然后将其上传到您的网站以减少页面重量和加载时间。使用具有自适应设计或视网膜屏幕的图像？响应式网站设计和视网膜屏幕不能证明图像调整大小。即使在这种情况下，也有一些方法可以将图片传送到合适的尺寸。我们建议您阅读以下资源：响应式图像简介Picturefill，开始使用元素RICG，致力于响应式图像的开发团队","categories":[{"name":"优化","slug":"优化","permalink":"https://www.elonchung.cn/categories/优化/"}],"tags":[{"name":"seo","slug":"seo","permalink":"https://www.elonchung.cn/tags/seo/"}]},{"title":"技术博文网站整理与推荐","slug":"awesome","date":"2018-04-09T05:21:52.000Z","updated":"2020-07-07T01:29:23.393Z","comments":true,"path":"2018/04/awesome/","link":"","permalink":"https://www.elonchung.cn/2018/04/awesome/","excerpt":"","text":"技术博文网站整理与推荐以下序号排名不分先后，只是便于整理，感谢各位作者或团队的分享。阅读工具主要使用：Feedly APP + 即刻APP + 微信APP + 开发者头条APP实在太懒了，以致于不知道怎么写推荐语，不过应该都是大家耳闻能详的，也欢迎大家推荐。酷 壳 – CoolShellhttp://coolshell.cn阮一峰的网络日志http://www.ruanyifeng.com/blog/阿里中间件团队博客http://jm.taobao.org/美团点评技术团队https://tech.meituan.com/InfoQ中文http://www.infoq.com/cn/并发编程网http://ifeve.com/IBM developerWorks 中国http://www.ibm.com/developerworks/cn/张逸http://zhangyi.farbox.com/程序猿DD博客http://blog.didispace.com/Martin Fowlerhttps://martinfowler.com/Spring官方博客http://spring.io/blogNetflix TechBloghttps://medium.com/netflix-techblogInfoQ英文http://www.infoq.com/IntelliJ IDEA Bloghttps://blog.jetbrains.com/ideaThe Effective Engineerhttp://www.effectiveengineer.com/The GitHub Bloghttps://github.com/blogTop Java Blogshttps://www.topjavablogs.com/大数据杂谈微信公众号【BigdataTina2016】高可用架构微信公众号【ArchNotes】架构师之路微信公众号【road5858】开涛的博客微信公众号【kaitao-1234567】聊聊架构微信公众号【archtime】你假笨微信公众号【lovestblog】思特沃克微信公众号【ThoughtWorks】携程技术中心微信公众号【ctriptech】中生代技术微信公众号【freshmanTechnology】阿里技术微信公众号【ali_tech】RednaxelaFXhttps://www.zhihu.com/people/rednaxelafx/activities李艳鹏http://www.jianshu.com/u/581f548ef0ec开发者头条https://toutiao.io/王楠博客http://wangnan.tech","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"}]},{"title":"常用的工具（个人收录-待完善）","slug":"tools","date":"2017-10-30T02:10:25.000Z","updated":"2020-07-07T01:36:14.523Z","comments":true,"path":"2017/10/tools/","link":"","permalink":"https://www.elonchung.cn/2017/10/tools/","excerpt":"","text":"常用的工具开发工具PHPstormzend studiosublimenotepad++Javacomposernode.jsWAMPSQLyog 数据库管理XMind 脑图Wireshark 抓包fiddler 抓包Beyond Compare 文件对比WinSCP 传输HiJson json显示Oracle VM VirtualBox 虚拟机homestead-7 虚拟测试环境RedisDesktopManager redis服务端管理VMware 虚拟机VMware vSphere Client 虚拟化工具Source Insight 代码审阅SwitchHosts HOST解析工具以下收藏链接php之路前端工具PHP资源大全中文版在线工具百度静态资源公共库有趣的lol技能(web掌握)检测工具代码管理svngitSourceTreelinux相关nginxapachephpmysqlredismemcachesvn以下收藏链接linux公社工具资料更新地址;linux依赖包关系查询chrome插件postmanjsonviewOneTab掘金SwitchyOmega广告净化器InfinityOctotree Code tree for GitHubAdvanced REST client插件网IDEA插件EasyCode 逆向工程free-mybatis-plugingsonformat json生成代码工具lombokMaven HelperMybatic log pluginRestfullToolkitStatisticTranslationrainbow-bracketsgrep-consolecodeglancewindows小工具Evernote 笔记RunBlock 程序禁用SpaceSniffer 硬盘空间占用procexp64 进程管理Security Process Explorer 进程屏蔽禁止Everything 资源快速搜索Shadowsocks V屁Nyou-get 视频下载12345678// 安装及下载命令pip3 install you-getpip3 install --upgrade you-getyou-get --playlist 'https://www.youtube.com/watch?v=jNQXAC9IVRw'// --playlist 列表下载// -i 查看下载格式// --format=flv 清晰度格式下载 最好选默认// -o d:/xx 下载路径微信公众号架构师之路DBAplus社群美团点评技术团队携程技术中心阿里技术CSDN大数据开源中国黑马公社伯乐在线聊聊架构壹佰案例高效开发运维","categories":[{"name":"tools","slug":"tools","permalink":"https://www.elonchung.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://www.elonchung.cn/tags/tools/"}]},{"title":"LAMP编译安装及配置篇——就是干","slug":"lamp","date":"2017-07-20T14:59:34.000Z","updated":"2018-05-05T04:41:55.876Z","comments":true,"path":"2017/07/lamp/","link":"","permalink":"https://www.elonchung.cn/2017/07/lamp/","excerpt":"","text":"LAMP：安装所需要系统库相关库文件安装安装包下载链接：http://download.csdn.net/detail/kc88168/5902111安装gcc1234yum install gcc gcc-c++ gcc-g77yum install make文件放到/usr/local/src/下全部解压for file in *.tar.gz; do tar -zxvf &quot;$&#123;file&#125;&quot;; done注：执行上面的语句之后的解压就不用再执行了安装libxml2最新库文件123tar zxvf libxml2-2.9.0.tar.gzcd libxml2-2.9.0 ./configure --prefix=/usr/local/libxml2安装zlib最新库文件123tar zxvf zlib.1.2.7.tar.gzcd ../zlib.1.2.7./configure安装libpng最新库文件123456789101112tar zxvf libpng-1.5.14.tar.gzcd ../libpng-1.5.14在./configure --prefix=/usr/local/libpng这步最后会提示：configure: error: ZLib not installed解决方法如下：进入zlib的源文件目录，执行命令 make clean,清除zlib；重新配置 ./configure,后面不要接--prefix参数；make &amp;&amp; make install；进入libpng目录，执行命令 ./configure --prefix=/usr/local/libpng;make &amp;&amp; make install；安装libmcrypt最新库文件1234567//tar zxvf libmcrypt-2.5.8.tar.gzcd ../libmcrypt-2.5.8./configure --prefix=/usr/local/libmcrypt安装完成libmcrypt库以后，不同的linux系统版本有可能还要安装一下libltdl库。cd /usr/local/src/libmcrypt-2.5.8/libltdl./configure --enable-ltdl-installmake &amp;&amp; make install安装jpeg8最新库文件12345678910cd ../jpeg-8b/mkdir /usr/local/jpeg8 //建立jpeg8软件安装目录mkdir /usr/local/jpeg8/bin //建立存放命令的目录mkdir /usr/local/jpeg8/lib //创建jpeg8库文件所在目录mkdir /usr/local/jpeg8/include //建立存放头文件目录mkdir -p /usr/local/jpeg8/man/man1 //建立存放手册的目录./configure \\--prefix=/usr/local/jpeg8/ \\--enable-share \\--enable-static警告:configure: WARNING: unrecognized options: –enable-share [可忽略]在安装GD2库配置时，可以在configure命令的选项中加上“–with-jpeg=/usr/local/jpeg8”选项，指定jpeg8库文件的位置。安装PHP时也要指定该库文件的位置。安装freetype最新库文件123tar zxvf freetype-2.4.10.tar.gzcd ../freetype-2.4.10./configure --prefix=/usr/local/freetype &amp;&amp; make &amp;&amp; make install安装atuoconf最新的库文件需要先装perl包1234yum install perlcd ../autoconf-2.69configure时，不用指定路径。./configure &amp;&amp; make &amp;&amp; make install安装最新的GD库文件1234567891011cd ../gd-2.0.35./configure \\ //配置命令--prefix=/usr/local/gd \\ //指定安装软件的位置--with-jpeg=/usr/local/jpeg8/ \\ //指定去哪找jpeg库文件--with-png=/usr/local/libpng/ \\ //指定去哪找png库文件--with-freetype=/usr/local/freetype/ //指定去哪找freetype 2.x字体库的位置./configure \\--prefix=/usr/local/gd \\--with-jpeg=/usr/local/jpeg8/ \\--with-png=/usr/local/libpng/ \\--with-freetype=/usr/local/freetype/如果安装成功会在/usr/local/gd/目录下存在bin、include和lib这三个目录。在安装PHP5时，通过在configure命令选项中加上“–with-gd=/usr/local/gd”选项，指定GD库文件的位置。如果报错:make[2]: [gd_png.lo] Error 1make[2]: Leaving directory `/tmp/gd-2.0.35’make[1]: [all-recursive] Error 1make[1]: Leaving directory `/tmp/gd-2.0.35’make: *** [all] Error 2解决方案:vi gd_png.c找到#include “png.h”改成#include “/usr/local/libpng/include/png.h”安装新版本的apache服务器1、卸载apr、apr-utilyum remove apr apr-util下载安装：http://apr.apache.org/download.cgiapr-1.4.6.tar.gzcd ../apr-1.4.6./configure –prefix=/usr/local/apr-httpd/ &amp;&amp; make &amp;&amp; make install下载安装：http://apr.apache.org/download.cgiapr-util-1.5.1.tar.gzcd ../apr-util-1.5.1./configure –prefix=/usr/local/apr-util-httpd/ –with-apr=/usr/local/apr-httpd/ &amp;&amp; make &amp;&amp; make install下载：http://sourceforge.net/projects/pcre安装新版本的pcre123unzip -o pcre-8.32.zipcd pcre-8.32./configure --prefix=/usr/local/pcre &amp;&amp; make &amp;&amp; make install安装apache12345678910111213141516171819202122232425cd ../httpd-2.4.4./configure \\--prefix=/usr/local/apache2 \\--enable-mods-shared=all \\--enable-deflate \\--enable-speling \\--enable-cache \\--enable-file-cache \\--enable-disk-cache \\--enable-mem-cache \\--enable-so \\--enable-expires=shared \\--enable-rewrite=shared \\--enable-static-support \\--sysconfdir=/etc/httpd \\--with-z=/usr/local/zlib/ \\--with-apr=/usr/local/apr-httpd/ \\--with-apr-util=/usr/local/apr-util-httpd/ \\--with-pcre=/usr/local/pcre/ \\--disable-userdir \\--enable-rewrite \\--enable-cgi \\--enable-ssl make &amp;&amp; make install修改配置123456789101112131415161718vi /etc/httpd/httpd.conf改ServerName localhost:80找AddType application/x-gzip .gz .tgz加上下面一行AddType application/x-httpd-php .php .phtml改设置默认读取index.后缀&lt;IfModule dir_module&gt; DirectoryIndex index.php index.phtml index.html index.htm&lt;/IfModule&gt;【下面可以改也可以不改】&lt;Directory /&gt; Options FollowSymLinks AllowOverride All Order allow,deny Allow from all&lt;/Directory&gt;重启apacheecho “/usr/local/apache2/bin/apachectl start” &gt;&gt; /etc/rc.d/rc.local安装数据库5.5安装所需要系统库相关库文件1234yum install ncurses-develyum install bisonyum –y install gcc gcc-c++ gcc-g77 autoconf automake zlib* fiex* libxml* \\ncurses-devel libmcrypt* libtool-ltdl-devel*创建mysql安装目录mkdir -p /usr/local/webserver/mysql/创建数据存放目录mkdir -p /data/mysql/创建用户和用户组与赋予数据存放目录权限groupadd mysqluseradd -g mysql mysqlchown mysql.mysql -R /data/mysql/安装cmake（mysql5.5以后是通过cmake来编译的）12345wget http://www.cmake.org/files/v2.8/cmake-2.8.4.tar.gztar zxvf cmake-2.8.4.tar.gzcd cmake-2.8.4./configuremake &amp;&amp; make install下载安装http://mirrors.sohu.com/mysql/MySQL-5.5/123456789101112131415wget http://mirrors.sohu.com/mysql/MySQL-5.5/mysql-5.5.32.tar.gztar zxvf mysql-5.5.30.tar.gzcd mysql-5.5.30cmake . \\-DCMAKE_INSTALL_PREFIX=/usr/local/mysql/ \\-DMYSQL_DATADIR=/var/lib/mysql \\-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysqld.sock \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DENABLED_LOCAL_INFILE=1 \\-DMYSQL_TCP_PORT=3306 \\-DEXTRA_CHARSETS=all \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DMYSQL_USER=mysql \\-DWITH_DEBUG=0[出现警告：The variable, ‘MYSQL USER’, specified manually, was not used during the generation. ，可以忽略]//需要时也可以把预编译里面的MYSQL_USER去掉，即可预编译成功！1234567891011 make &amp;&amp; make install- 复制配置文件 # cp support-files/my-medium.cnf /etc/my.cnf # cp support-files/mysql.server /etc/init.d/mysqld # chmod 755 /etc/init.d/mysqld- 初始化数据库 bash scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql/- 启动mysql服务 # /etc/init.d/mysqld start 或者service mysqld start ps –ef | grep mysql 查看是否启动 /usr/local/mysql/bin/mysql -u root -p 登录数据库//打开/etc/selinux/config，把SELINUX=enforcing改为SELINUX=disabled后存盘退出重启机器试试3.本来初始化配置是这样的：scripts/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysql出现了[root@localhost mysql-5.6.14]# service mysql restartERROR! MySQL server PID file could not be found!Starting MySQL. ERROR! The server quit without updating PID file (/var/lib/mysql/localhost.localdomain.pid).在日志中出现了如下错误：Can’t open and lock privilege tables: Table ‘mysql.user’ doesn’t exist后来采用了下面的语句就可以了：scripts/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysql –ldata=/var/lib/mysql安装php5先修改后面的错误再./configure12345678910111213141516./configure \\--prefix=/usr/local/php \\--with-config-file-path=/usr/local/php/etc \\--with-apxs2=/usr/local/apache2/bin/apxs \\--with-mysql=/usr/local/mysql/ \\--with-libxml-dir=/usr/local/libxml2/ \\--with-png-dir=/usr/local/libpng/ \\--with-jpeg-dir=/usr/local/jpeg8/ \\--with-freetype-dir=/usr/local/freetype/ \\--with-gd=/usr/local/gd/ \\--with-zlib-dir=/usr/local/zlib/ \\--with-mcrypt=/usr/local/libmcrypt/ \\--with-mysqli=/usr/local/mysql/bin/mysql_config \\--enable-soap \\--enable-mbstring=all \\--enable-sockets错误 make: [ext/gd/gd.lo] error/usr/local/src/php-5.4.3/ext/gd/gd_ctx.c: In function ‘_php_image_output_ctx’:/usr/local/src/php-5.4.3/ext/gd/gd_ctx.c:153: error: ‘gdIOCtx’ has no member named ‘data’make: [ext/gd/gd.lo] Error 1解决vi &lt;gd_dir&gt;/include/gd_io.hvoid (gd_free) (struct gdIOCtx );加void (*data);}gdIOCtx;我的GD安装在/usr/local/gd2目录下，所以是#vi vi /usr/local/gd/include/gd_io.hlibltdl.so.3: cannot open shared object file: No such file or directorymake: *** [ext/phar/phar.php] Error 127解决方法：ln -s /usr/local/lib/libltdl.so.3 /usr/lib/libltdl.so.3cd /usr/local/libpng/lib/lslibpng15.a libpng15.so libpng15.so.15.10.0 libpng.la pkgconfiglibpng15.la libpng15.so.15 libpng.a libpng.so可以看到libpng15.so.15然后修改/etc/ld.so.conf 文件：vi /etc/ld.so.conf在第一行下面追加/usr/local/libpng/lib这个路径。然后重新编译安装即可。1234567cp php.ini-development /usr/local/php/etc/php.inivi /usr/local/php/etc/php.ini修改 date.timezone =&quot;PRC&quot;/usr/local/apache2/bin/apachectl stop/usr/local/apache2/bin/apachectl stopphpMyAdmin的安装1、进入软件源码所在的目录/usr/local/src/中，并解压软件包phpMyAdmin-3.5.6-all-languages.tar.gz到当前目录phpMyAdmin-3.5.6-all-languages下。2、把解压的目录phpMyAdmin-3.5.6-all-languages下的文件，全部复制到Apache的/usr/local/apache243/htdocs下，并新建一个名为phpmyadmin的目录下面，即安装完成。cp -a phpMyAdmin-3.5.6-all-languages /usr/local/apache2/htdocs/phpmyadmin3、在使用phpmyadmin之前，也需要先配置一下。配置的方法是通过对phpmyadmin顶层目录下的config.inc.php文件中 的几个选项做一些设置即可。默认不存在config.inc.php文件，我们需要手工创建一个，也可以复制config.sample.inc.php 模板得到最低限度的配置文件。123456789[root@localhost src]# cd /usr/local/apache2/htdocs/phpmyadmin/[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.phpvi config.inc.php$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;]=&apos;http&apos;;//如果想让phpMyAdmin使用HTTP身份验证模式$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;]=&apos;cookie&apos;;//无需输入密码登陆$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;]=&apos;config&apos;;$cfg[&apos;Servers&apos;][$i][&apos;user&apos;]=&apos;root&apos;;$cfg[&apos;Servers&apos;][$i][&apos;password&apos;]=&apos;654321&apos;;","categories":[{"name":"LAMP","slug":"LAMP","permalink":"https://www.elonchung.cn/categories/LAMP/"}],"tags":[{"name":"LAMP","slug":"LAMP","permalink":"https://www.elonchung.cn/tags/LAMP/"}]},{"title":"Logback打印日志","slug":"logbak","date":"2017-07-20T14:59:34.000Z","updated":"2020-08-11T12:24:27.969Z","comments":true,"path":"2017/07/logbak/","link":"","permalink":"https://www.elonchung.cn/2017/07/logbak/","excerpt":"","text":"Logback打印日志application.properties123456# 开发环境配置# 数据源配置，请修改为你项目的实际配置spring.datasource.url=jdbc:log4jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=net.sf.log4jdbc.sql.jdbcapi.DriverSpylog4jdbc.log4j2.properties1234# If you use SLF4J. First, you need to tell log4jdbc-log4j2 that you want to use the SLF4J loggerlog4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegatorlog4jdbc.auto.load.popular.drivers=falselog4jdbc.drivers=com.mysql.jdbc.Driverlogback.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\" debug=\"false\"&gt; &lt;contextName&gt;ModelName&lt;/contextName&gt; &lt;property name=\"log.charset\" value=\"utf-8\" /&gt; &lt;property name=\"LOG_HOME\" value=\"G:\\logs\\platform\" /&gt; &lt;property name=\"log.pattern\" value=\"%black(%contextName-) %red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger&#123;36&#125;) - %gray(%msg%n)\" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;log.charset&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--普通日志输出到控制台--&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/root&gt; &lt;!--监控sql日志输出 --&gt; &lt;logger name=\"jdbc.sqlonly\" level=\"INFO\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;logger name=\"jdbc.resultset\" level=\"ERROR\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;!-- 如想看到表格数据，将OFF改为INFO --&gt; &lt;logger name=\"jdbc.resultsettable\" level=\"OFF\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;logger name=\"jdbc.connection\" level=\"OFF\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;logger name=\"jdbc.sqltiming\" level=\"OFF\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;logger name=\"jdbc.audit\" level=\"OFF\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt;&lt;/configuration&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 该配置主要是打印 logback 的配置信息 --&gt; &lt;statusListener class=\"ch.qos.logback.core.status.OnConsoleStatusListener\"/&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"ACCESS\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;logs/access-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 10天 --&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 日志级别限制 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY &lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--日志文件最大的大小 --&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!--sql 打印在控制台--&gt; &lt;logger name=\"jdbc.sqltiming\" level=\"INFO\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/logger&gt; &lt;logger name=\"jdbc.resultsettable\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;logger name=\"jdbc.sqlonly\" level=\"OFF\"&gt;&lt;/logger&gt; &lt;logger name=\"jdbc.audit\" level=\"OFF\"&gt;&lt;/logger&gt; &lt;logger name=\"jdbc.resultset\" level=\"OFF\"&gt;&lt;/logger&gt; &lt;logger name=\"jdbc.connection\" level=\"OFF\"&gt;&lt;/logger&gt; &lt;!--同时记录log日志--&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"ACCESS\" /&gt; &lt;/root&gt; &lt;/configuration&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt;&lt;!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --&gt;&lt;!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --&gt;&lt;!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --&gt;&lt;!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"true\"&gt; &lt;!-- 动态日志级别 --&gt; &lt;jmxConfigurator/&gt; &lt;!--*****************************************************************************--&gt; &lt;!--自定义项 开始--&gt; &lt;!--*****************************************************************************--&gt; &lt;!-- 定义日志文件 输出位置 --&gt; &lt;property name=\"log.home_dir\" value=\"G:/usr/local/springboot/log\"/&gt; &lt;property name=\"log.app_name\" value=\"http-demo\"/&gt; &lt;!-- 日志最大的历史 30天 --&gt; &lt;property name=\"log.maxHistory\" value=\"30\"/&gt; &lt;property name=\"log.maxSize\" value=\"5MB\"/&gt; &lt;!-- 日志界别 --&gt; &lt;property name=\"log.level\" value=\"info\"/&gt; &lt;!-- 打印sql语句 需要指定dao层包的位置 --&gt; &lt;property name=\"mapper.package\" value=\"com.example.demo.mapper\" /&gt; &lt;!--*****************************************************************************--&gt; &lt;!--自定义项 结束--&gt; &lt;!--*****************************************************************************--&gt; &lt;!-- ConsoleAppender 控制台输出日志 --&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt; &lt;!-- 设置日志输出格式 --&gt;&lt;!-- %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] [%thread] %logger - %msg%n--&gt; %black(%contextName-) %red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger&#123;36&#125;) - %gray(%msg%n) &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- ERROR级别日志 --&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender --&gt; &lt;appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 过滤器，只记录WARN级别的日志 --&gt; &lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!-- 设置过滤级别 --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;!-- 用于配置符合过滤条件的操作 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 用于配置不符合过滤条件的操作 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责触发滚动 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt; $&#123;log.home_dir&#125;/error/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log &lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 --&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;!--日志文件最大的大小--&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt; &lt;!-- 设置日志输出格式 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- WARN级别日志 appender --&gt; &lt;appender name=\"WARN\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 过滤器，只记录WARN级别的日志 --&gt; &lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!-- 设置过滤级别 --&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;!-- 用于配置符合过滤条件的操作 --&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;!-- 用于配置不符合过滤条件的操作 --&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log.home_dir&#125;/warn/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;!--当天的日志大小 超过MaxFileSize时,压缩日志并保存--&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- INFO级别日志 appender --&gt; &lt;appender name=\"INFO\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.home_dir&#125;/info/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG级别日志 appender --&gt; &lt;appender name=\"DEBUG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.home_dir&#125;/debug/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- TRACE级别日志 appender --&gt; &lt;appender name=\"TRACE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;TRACE&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.home_dir&#125;/trace/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--设置一个向上传递的appender,所有级别的日志都会输出--&gt; &lt;appender name=\"app\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.home_dir&#125;/app/%d&#123;yyyy-MM-dd&#125;/$&#123;log.app_name&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;$&#123;log.maxHistory&#125;&lt;/maxHistory&gt; &lt;MaxFileSize&gt;$&#123;log.maxSize&#125;&lt;/MaxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--org.springframework.web包下的类的日志输出--&gt; &lt;logger name=\"org.springframework.web\" additivity=\"false\" level=\"WARN\"&gt; &lt;appender-ref ref=\"WARN\"/&gt; &lt;/logger&gt; &lt;!--dao层包下的类的日志输出--&gt; &lt;logger name=\"$&#123;mapper.package&#125;\" additivity=\"false\" level=\"DEBUG\"&gt; &lt;appender-ref ref=\"app\"/&gt; &lt;appender-ref ref=\"ERROR\"/&gt; &lt;!--打印控制台--&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/logger&gt; &lt;!-- root级别 DEBUG --&gt; &lt;root&gt; &lt;!-- 打印debug级别日志及以上级别日志 --&gt; &lt;level value=\"$&#123;log.level&#125;\"/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;!-- 不管什么包下的日志都输出文件 --&gt; &lt;!--&lt;appender-ref ref=\"ERROR\"/&gt;--&gt; &lt;!--&lt;appender-ref ref=\"INFO\"/&gt;--&gt; &lt;!--&lt;appender-ref ref=\"WARN\"/&gt;--&gt; &lt;!--&lt;appender-ref ref=\"DEBUG\"/&gt;--&gt; &lt;!--&lt;appender-ref ref=\"TRACE\"/&gt;--&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[{"name":"Logback","slug":"Logback","permalink":"https://www.elonchung.cn/categories/Logback/"}],"tags":[{"name":"Logback","slug":"Logback","permalink":"https://www.elonchung.cn/tags/Logback/"}]},{"title":"Sublime的插件","slug":"sublime-package","date":"2017-07-11T06:47:42.000Z","updated":"2018-05-03T15:23:23.686Z","comments":true,"path":"2017/07/sublime-package/","link":"","permalink":"https://www.elonchung.cn/2017/07/sublime-package/","excerpt":"","text":"Markdown相关插件MarkdownOmniMarkupPreviewer配置","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"}]},{"title":"高级PHP知识点","slug":"php-knowledge","date":"2017-07-10T02:21:34.000Z","updated":"2018-05-05T04:43:08.279Z","comments":true,"path":"2017/07/php-knowledge/","link":"","permalink":"https://www.elonchung.cn/2017/07/php-knowledge/","excerpt":"","text":"1. mysqli类似与PDO，是一个存取mysql的函数库，php官方推荐与PDO相比它仅支持mysql，PDO支持12中不同的数据库引擎两者都提供了OOP的支持，但是mysqli还支持函数式（过程式）的APIPDO支持名称式参数，mysqli不支持，例如：1234567$params = array(':username' =&gt; 'test', ':email' =&gt; $mail, ':last_login' =&gt; time() - 3600); $pdo-&gt;prepare(' SELECT * FROM users WHERE username = :username AND email = :email AND last_login &gt; :last_login');$pdo-&gt;execute($params);2. 如何在PHP中保持长链接polling &amp; long polling 最基本，废弃，性能差websocket 高并发不能用select，win要用iocp，linux要用epoll（现成的扩展libevent）高并发继续增长，单进程的websocket无法满足，拆成多进程，新问题：进程间通信、负载均衡、session唯一等，现成方案可以使用swoole3. php内存泄露问题：当你在Linux下频繁存取文件后,物理内存会很快被用光,当程序结束后,内存不会被正常释放,而是一直作为caching。解决方案：处理一个文件后手动释放一下内存（sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches）症状都表现为内存占用的持续增长php.ini中的auto_append_file和auto_prepend_file可以在每个请求前后注入代码，配合查询/proc/{$pid}/status中的相应记录可以知道每个进程内存占用情况，php可以使用getmypid()函数获取当前进程的idphp5.2使用引用计数垃圾回收机制，php5.3使用“引用计数系统中的同步周期回收”（Concurrent Cycle Collection in Reference Counted Systems），是在引用计数的基础上加入了同步循环回收，可以解决循环引用引起的内存泄漏。4. 事务里如果不同表的引擎不同会怎样MyISAM不支持事务，InnoDB支持语句会正常执行，但不支持事务的引擎涉及的表会无法回滚5. explain里面有两列是跟索引有关的，是什么？possible_keys：可能可以利用的索引的名字。这里的索引名字是创建索引时指定的索引昵称；如果索引没有昵称，则默认显示的是索引中第一个列的名字（在本例中，它是“firstname”）。默认索引名字的含义往往不是很明显。key：它显示了MySQL实际使用的索引的名字。如果它为空（或NULL），则MySQL不使用索引。key_len：索引中被使用部分的长度，以字节计6. SQL如何调优？如何发现执行慢的SQL？使用mysql的慢日志来记录所有的慢sql，默认记录执行时间超过10s的sql使用explain来分析sql的执行情况；使用show processlist; 命令查看当前mysql的运行情况；7. memcached集群如何存储数据和保持一致性？取模算法一致性哈希算法session与一般缓存数据在服务器级别分离，将session存在独立的服务器池中使用magent缓存代理实现高可用（session重建可用这种方式避免）8. 数据库是如何做集群的，主备之间是如何做数据同步的？mysql本身支持主从同步的设置，在my.conf中做相应设置（client id），原理是基于主数据库的日志，在从服务器上执行日志中相同的sql阿里的Cobar，官方的MySQL Cluster（商业案例不多）读写分离，会增加开发的复杂度，读取的数据也不容易保证实时9. 解释下php-fpm的相关概念和作用CGI是一个协议，FastCGI是CGI的升级，还是一个协议，php-fpm是fastCGI的PHP实现，参考：https://segmentfault.com/q/1010000000256516实现了FastCGI协议的PHP进程管理器，PHP5.3以后才被官方默认加入，之前只是个第三方插件功能包括：支持平滑停止/启动的高级进程管理功能；可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）；stdout 和 stderr 日志记录;发生意外情况的时候能够重新启动并缓存被破坏的 opcode;文件上传优化支持;&#8220;慢日志&#8221; &#8211; 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;fastcgi_finish_request() &#8211; 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）；动态／静态子进程产生；基本 SAPI 运行状态信息（类似Apache的 mod_status）；基于 php.ini 的配置文件。10. 悲观锁和乐观锁 参考连接悲观锁：假定会发生并发冲突，一上来先加锁，再进行读写操作。优点：没有脏读，缺点：数据加锁时间较长，影响并发性能乐观锁：假定不会发生并发冲突，只在提交更改时才加锁，读取和更改时并不加锁。优点：并发性能好，缺点：有脏读的可能结论：在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法.11. 接口加密措施加密算法：MD5、Sha1、Sha256、AES/DES、非对称加密（公钥私钥）加签名：传递的信息为明文，仅做防篡改校验直接对接口传递的信息进行加密，即传递的信息非明文，加密算法可以使用上述加密算法https协议，整个请求使用ssl进行加密，传递的信息非明文，但是用fiddle等工具仍可解密，因此敏感信息仍需结合上述两种方法进行加密和防篡改OAuth2.0例子：Jane (用户,资源的所有者) 将自己度假的照片 (受保护资源) 上传到了图片分享网站A (服务提供方).她现在想要在另外一个网站B (Client, 消费方) 在线打印这些照片. 一般情况下, Jane 需要使用自己的用户名和密码登陆网站A.但是, Jane 并不希望将自己的用户名和密码泄露给网站B. 可是网站B需要访问图片分享网站A的图片并将其打印出来.基于令牌（token）的身份认证和权限控制，平安玩的passport就是OAuth2.0的一个实现12. nginx如何配置负载均衡 参考连接Nginx负载均衡是通过upstream模块来实现的内置实现了三种负载策略：轮询（默认）：根据请求次数，将每个请求均匀分配到每台服务器，可以为每台服务器分配不同的权重（weight，默认为1），权重高的被分配的几率相应增大最少连接：将请求分配到连接数最少的服务器上，Nginx会统计哪些服务器的连接数最少IP Hash：使用hash算法将客户端IP分配到不同的服务器上，后续该IP的所有请求均分配到之前分配的服务器上13. 打点统计 监控措施 监控工具第三方打点统计API，如Google Analytics等目前在做的项目：交易一致性监控，单独部署的服务器在备库上对第三方订单进行反查跑批，比对双方订单状态及金额的一致性第三方监控工具，目前在用的zabbix，系统和网络性能监控，zabbix服务端可以独立运作，也可以结合zabbix agent完成更多监控工作。14. php5.5特性生成器(Generators)密码哈希APIfinallyempty()支持函数调用和表达式类名解析foreach改进：支持list()15. autoload原理: 参考16. redis集群：参考17. mysql连接池18. 如何配置PHP的session存储在缓存修改php.ini配置文件实现。修改session存储方式session.save_handler = memcached修改session存储地址，号替换为你的IP:Port, 在管理中心，点击“云缓存Memcached”，在云缓存 Memcached“管理视图”，可以看到系统分配的IP:Portsession.save_path = “…:*”设置一个合理时间，只缓存热点数据session.gc_maxlifetime = 1500代码中直接设置。ini_set(“session.save_handler”,”memcached”);ini_set(“session.save_path”,”…:**”);ini_set(“session.gc_maxlifetime”,1500);19. PHP实现接口20. 大文件读取使用fopen和fseek逐行或逐块读取","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"}]},{"title":"学会如何构建高性能MySQL系统","slug":"sql-optimize","date":"2017-07-10T01:31:05.000Z","updated":"2020-07-07T01:39:24.264Z","comments":true,"path":"2017/07/sql-optimize/","link":"","permalink":"https://www.elonchung.cn/2017/07/sql-optimize/","excerpt":"","text":"简介最近在压测新的存储，正好把工作过程中积累的对高性能MySQL相关的知识体系构建起来，做成思维导图的方式。总结乃一家之言，有不妥之处，望给位读者朋友指正。思维导图构建高性能MySQL系统涵盖从单机、硬件、OS、文件系统、内存到MySQL 本身的配置，以及schema 设计、索引设计 ，再到数据库架构上的水平和垂直拓展。内容展示硬件（1）CPUCPU亲和性：确保每个io都被其发起的CPU处理echo 2 &gt; /sys/block//queue/rq_affinity选择最大性能模式，避免节能模式导致性能不足关闭NUMA，降低swap概率numactl –interleave=all（2）RAID卡选择FORCE WB读写策略选择合适的充放电策略高IO，推荐RAID10空间需求大则RAID5操作系统（1）IO调度策略SSD/PCIE SSD推荐noop，其它推荐deadlineecho noop &gt; /sys/block//queue/scheduler（2）禁用块设备轮转模式echo 0 &gt; /sys/block//queue/rotational（3）内存vm.swappiness=0内存最大性能模式文件系统确保4K对⻬，如果使用全盘一个分区，例如mkfs.ext4 /dev/dfa也可以使用xfs 构建文件系统。禁止atime、diratimemount -o noatime -o nodiratime开启trimmount -o discard关闭barrier12mount -o barrier=0/dev/sdc1 /data ext4 defaults,noatime,nodiratime,nobarrier 0 0MySQL配置优化IO相关参数innodb_flush_method = O_DIRECTinnodb_read_io_threads = 16innodb_write_io_threads = 16innodb_io_capacity = 3000（PCIE卡建议更高）innodb_flush_neighbors=0InnoDB存储引擎在刷新一个脏页时，会检测该页所在区(extent)的所有页，如果是脏页，那么一起刷新。这样做的好处是通过AIO可以将多个IO写操作合并为一个IO操作。对于传统机械硬盘建议使用，而对于固态硬盘可以关闭innodb_flush_log_at_trx_commitredo 的刷盘策略sync_binlogbinlog 的刷盘策略innodb_log_buffer_size建议8-16M，有高TPS（比如大于6k）的可以提高到32M，系统tps越高设置可以设置的越大推荐文章： www.cnblogs.com/conanwang/p/5849437.html内存分配策略：jemalloc是BSD的提供的内存分配管理tcmalloc是google的内存分配管理模块ptmalloc是glibc的内存分配管理malloc-lib= /usr/lib64/libjemalloc.so.1系统资源：malloc-lib= /usr/lib64/libjemalloc.so.1back_log：大于max_connectionsthread_stack=192并发控制：使用thread_poolthread_cache_sizeschema优化索引优化目标：利用最小的索引成本找到最需要的行记录。原则：最左前缀原则：MySQL会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a=1 and b=2 and c&gt;3 and d=4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整避免重复索引：idx_abc多列索引,相当于创建了(a)单列索引，(a,b)组合索引以及(a,b,c)组合索引。不在索引列使用函数 如 max(id)&gt; 10 ,id+1&gt;3 等尽量选择区分度高的列作为前缀索引：区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少推荐文章：MySQL索引原理及慢查询优化http://tech.meituan.com/mysql-index.htmlMySQL索引实践http://blog.coderland.net/mysql/2015/08/26/MySQL%E7%B4%A2%E5%BC%95%E5%AE%9E%E8%B7%B5/由浅入深探究 MySQL索引结构原理、性能分析与优化http://blog.jobbole.com/87107/SQL开发优化不使用存储过程、触发器，自定义函数不使用全文索引不使用分区表针对OTLP业务尽量避免使用多表join和子查询不使用*,SELECT使用具体的列名：在发生列的增/删时，发生列名修改时，最大限度避免程序逻辑中没有修改导致的BUG，IN的元素个数300-500避免使用大事务，使用短小的事务：减少锁等待和竞争禁止使用%前缀模糊查询 where like ‘%xxx’禁止使用子查询，遇到使用子查询的情况，尽量使用join代替遇到分页查询，使用延迟关联解决：分页如果有大offset，可以先取Id，然后用主键id关联表会提高效率禁止并发执行count(*)，并发导致CPU飙高禁止使⽤order by rand()不使用负向查询，如 not in/like，使用in反向代替不要一次更新大量（大于30000条）数据，批量更新/删除SQL中使用到OR的改写为用 IN() （or的效率没有in的效率高）数据库架构单实例无法解决空间和性能需求时考虑拆分垂直拆分水平拆分引入缓存系统说明IO相关的优化可能还不完整，以后会逐步完善。关于数据库系统水平和垂直拆分是一个比较大的命题，这里略过，每个公司的业务规模不一样，选取的拆分策略也有所不同。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.elonchung.cn/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.elonchung.cn/tags/数据库/"}]},{"title":"基于RabbitMQ和Swoole实现的一个完整的异步任务系统","slug":"php-style","date":"2017-07-09T14:31:23.000Z","updated":"2018-05-05T04:44:40.947Z","comments":true,"path":"2017/07/php-style/","link":"","permalink":"https://www.elonchung.cn/2017/07/php-style/","excerpt":"","text":"从最开始的使用redis实现的单进程消费的异步任务系统到加入swoole的多进程消费模式，现在，我们的异步任务系统终于又能迈进一步。因为有了前面两个简单系统的经验，这回基于RabbitMQ的异步任务系统设计的的更加完善，包括多进程消费，异常重试等。系统介绍消费端架构图从图中可以看到，我们这个系统是一个基于事件的异步任务系统。就是说当一个事件产生时，生产者将事件抛给调度器，调度器负责查询事件下有哪些任务，然后将这些任务丢到相应的队列中，最后由消费者消费任务队列中的任务。在整个系统中主要分为三大部分1.事件生产者，即产生消息事件的一方。2.任务调度器(Scheduler)，负责注册事件并调度任务。3.消费者(Worker)，负责消费任务队列中的任务。事件生产者事件生产者很简单，在业务系统中直接调用即可，代码如下。123456789require_once __DIR__.'/../autoload.php';use Asynclib\\Ebats\\Event;try&#123; $event = new Event('order_paied'); //定义事件 $event-&gt;setOptions(['order_id' =&gt; 'FB138020392193312']); //事件产生的参数 $event-&gt;publish();&#125;catch (Exception $exc)&#123; echo $exc-&gt;getMessage();&#125;任务调度器调度器主要做两件事，一是注册事件，另一个是调度任务。注册事件代码如下：//注册事件EventManager::register(‘order_create’, ‘closeOrder’, ‘demo’, 10);//关闭未付款订单(延迟任务)EventManager::register(‘order_paied’, ‘virtualShipping’, ‘demo’); //虚拟商品自动发货这样就注册了两个事件，事件下各有一个任务。具体调度部分代码很简单，就不多赘述，有兴趣的可以去看代码。消费者重头戏来了，一个异步任务系统最重要的就是消费端了，现在让我们来看下Worker的流程图。一个完整的消费进程可以看到，在这里我们采用了两个交换器和两个队列，一个负责处理正常的任务即ntask，另一个负责处理需要延迟执行的任务即dtask。简单描述下一个任务的生命周期。正常任务task产生，进入正常任务的交换器Exchange[ebats_core_ntask]交换器根据topic将任务分发到对应的队列中子进程ntask阻塞等待成功获取到task，并执行该任务执行失败，需要重试时抛出RetryException，不需要重试时抛出TaskException子进程ntask捕获到重试异常将任务抛给延迟任务的交换器Exchange[ebats_core_dtask]将任务执行信息回调给上层开发者以便保存查看延迟任务子进程dtask阻塞等待成功获取到task，并执行该任务执行失败，需要重试时抛出RetryException，不需要重试时抛出TaskException子进程dtask捕获到重试异常将任务抛给延迟任务的交换器Exchange[ebats_core_dtask]将任务执行信息回调给上层开发者以便保存查看消费者代码如下：1234567891011require_once __DIR__.'/../autoload.php';require_once __DIR__.'/task/TaskDemoModel.php';use Asynclib\\Ebats\\Worker;//执行结果回调函数$callback = function ($topic, $taskid, $taskname, $params, $timeuse, $message)&#123;&#125;;$worker = new Worker($callback); //支持多进程消费默认为1$worker-&gt;setQueue('demo'); //队列名和事件的topic一一对应$worker-&gt;run();自定义调度器一般来说这是一个基于事件的任务系统，那么能不能直接产生任务呢。答案是肯定的。只需要创建一个自定义调度器，由您自行实现调度逻辑，最终生成一个任务即可。代码如下：123456789101112131415161718192021require_once __DIR__.'/../autoload.php';use Asynclib\\Ebats\\Task;use Asynclib\\Core\\Consumer;use Asynclib\\Amq\\ExchangeTypes;use Asynclib\\Exception\\ExceptionInterface;/** * 本示例演示了如何创建一个自定义调度器,开发者可以根据自身需求开发自己的任务调度器 */try&#123; $worker = new Consumer(); $worker-&gt;setExchange('order_fanout', ExchangeTypes::TOPIC); $worker-&gt;setQueue('shzf_order_paied', ['*.*.WAIT_SELLER_SEND_GOODS']); $worker-&gt;run(function($key, $msg)&#123; $order_data = json_encode($msg); echo \" [$key] $order_data \\n\"; Task::create('demo', 'orderAsync', $msg);//创建任务,之后消息将作为参数由任务接管处理 &#125;);&#125;catch (ExceptionInterface $exc)&#123; echo $exc-&gt;getMessage();&#125; 这样，当接收到消息时就会产生一个orderAsync的任务，您只需要启动一个用来消费这个Topic的Worker即可。也许你会觉得这里直接写业务逻辑的代码就可以了，实际上也确实可以。当你可以忍受一个进程慢慢消费的时候是可以这样做的。但大多数情况下我们还是希望它能够尽快的消费掉，所以建议这里只负责创建任务，具体任务的业务逻辑由worker去执行。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"https://www.elonchung.cn/tags/Swoole/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.elonchung.cn/tags/RabbitMQ/"}]},{"title":"当前Web高效开发必备的PHP框架","slug":"framework","date":"2017-07-09T05:21:52.000Z","updated":"2018-05-05T04:59:32.078Z","comments":true,"path":"2017/07/framework/","link":"","permalink":"https://www.elonchung.cn/2017/07/framework/","excerpt":"","text":"多功能 THinkPHP 开源框架项目简介：使用 THinkPHP 开发项目的过程中把一些常用的功能或者第三方 sdk 整合好，开源供亲们参考，如 Auth 权限管理、支付宝、微信支付、阿里oss、友盟推送、融云即时通讯、云通讯短信、Email、Excel、PDF 等等。这些都是经过线上运营考验的，无毒害可以免费放心折腾使用。只要不会某一天找到我说因为借鉴了这个开源产品的一些方法，而导致了好几个亿的损失，要我负责并赔偿就好~ ￣へ￣此开源产品面向所有 THinkPHP 开发用户，因为我的基本思想是不改动框架的源文件，只是围绕着框架扩展，所以整合的这些功能都可以无痛兼容各种环境，既可以按照文章将整合的这些功能方便的移植到你已有的项目中，也可以直接以此项目为基础开发。项目地址基于 Laravel 的轻量级 web 部署系统 FixhubFixhub项目简介：Fixhub 是一款免费、开源，基于 Laravel 5.3 框架开发的 web 自动部署系统。目前实现的功能主要包括：支持 PHP、Python、JAVA、Ruby 等项目的发布。通过 SSH 将程序部署到多台服务器上。直接从 Git 仓库克隆项目代码并进行打包、安装。执行远程服务器 bash 命令。通过 Websocket 实现项目部署状态的实时跟踪。在服务器保留追溯版本记录，以便快速回滚。通过任务计划进行项目健康检测。可通过 webhook 触发部署。上线单申请、审核流程。Slack 和邮件通知。项目地址基于 Yii 框架协同办公管理系统 IBOS项目简介：IBOS 是一个基于PHP开发、Yii框架、免费开源的，快速、高效的协同办公管理系统。最新的 IBOS 为协同办公应用开发提供了强有力的支持，这些支持包括：复杂的用户组织结构管理支持。灵活和完善的角色权限控制体系，权限粒度支持到方法的权限设置。实用的功能和完善的插件机制。模块化的功能应用机制，可单独安装卸载单个应用。云平台支持-提供了对新浪 SAE 平台和本地环境双重支持的选择，具备“横跨性”和“平滑性”，支持本地化开发和调试以及部署切换。缓存支持-提供了包括文件、数据库、Memcache、Xcache、Redis 等多种类型的缓存支持。项目地址基于 CodeIgniter 框架的 CMS项目简介：菜鸟 CMS 是用 CodeIgniter + bootstrap2.0 面向开发人员的通用管理后台，视情况而定是否运用到你自己的项目中，其主要功能包括：权限模块会员模块文章模块幻灯片模块类别模块缓存模块日志模块系统设置项目地址基于 zend 开发的 CMF 系统项目简介：本项目是一个基于 zend framework 1.12.3 开发的 CMF 系统。在不改动 zend framework 代码的基础上构建的基于 app 的 CMF 系统。自带后台，以及安装模块。对 zend framework 的 ini 配置文件进行缓存，大大提高了 zend framework 的运行速度。巧妙的使用 zend framework 的 layout ,view 模块，使各 app 模块，可以使用全局 layout 进行布局，也可以 app 模块自定义的布局，（默认情况下 app 模块未定义 layout 布局将使用全局布局)。数据库通过定义可以开启读写分离功能，通过配置 ini 文件，可以很方便的分库，各分库之间的功能可以无缝调用。每个 app 模块包含有一个 library 库，各 app 模块 libray 库，可以互相调用，libray 分 dao,service,tool 三层结构，非常方便以后扩展。类库实现自动加载，不需要特意 include。等等还有许多其他功能，适合初学 zend framework 的开发人员学习以及高级开发人员在项目中使用。项目地址基于 phalcon 开发的内容管理系统项目简介：本项目是基于 Phalcon 开发的内容管理系统。 特性：继承 Phalcon 框架全功能。多网站支持，异站点用户文件、同网站私有/共有网站隔离。强大的个性化环境，每个用户可以对网站内容和表现形式进行个性化设置。基于用户角色、模块、角色的权限控制系统，当然，您也可以通过回调函数进行更精细控制。提供的站内搜索系统原生支持全文搜索。使用 volt 编写主题模板，类 twig 语法，单比 twig 更高效。Tolowan 提供的实体管理、字段管理、表单管理、模型管理等机制，可以大大缩减二次开发的难度和所需时间。项目地址","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"},{"name":"PHP框架","slug":"PHP框架","permalink":"https://www.elonchung.cn/tags/PHP框架/"}]},{"title":"MySQL的子查询","slug":"zichaxun","date":"2017-07-09T05:21:52.000Z","updated":"2018-05-05T04:53:09.762Z","comments":true,"path":"2017/07/zichaxun/","link":"","permalink":"https://www.elonchung.cn/2017/07/zichaxun/","excerpt":"","text":"一、子查询定义定义：子查询允许把一个查询嵌套在另一个查询当中。子查询，又叫内部查询，相对于内部查询，包含内部查询的就称为外部查询。子查询可以包含普通select可以包括的任何子句，比如：distinct、 group by、order by、limit、join和union等；但是对应的外部查询必须是以下语句之一：select、insert、update、delete、set或 者do。子查询的位置： select 中、from 后、where 中.group by 和order by 中无实用意义。二、子查询分类子查询分为如下几类：标量子查询：返回单一值的标量，最简单的形式。列子查询：返回的结果集是 N 行一列。行子查询：返回的结果集是一行 N 列。表子查询：返回的结果集是 N 行 N 列。可以使用的操作符：= &gt; &lt; &gt;= &lt;= &lt;&gt; ANY IN SOME ALL EXISTS一个子查询会返回一个标量（就一个值）、一个行、一个列或一个表，这些子查询称之为标量、行、列和表子查询。如果子查询返回一个标量值（就一个值），那么外部查询就可以使用：=、&gt;、&lt;、&gt;=、&lt;=和&lt;&gt;符号进行比较判断；如果子查询返回的不是一个标量值，而外部查询使用了比较符和子查询的结果进行了比较，那么就会抛出异常。标量子查询：是指子查询返回的是单一值的标量，如一个数字或一个字符串，也是子查询中最简单的返回形式。 可以使用 = &gt; &lt; &gt;= &lt;= &lt;&gt; 这些操作符对子查询的标量结果进行比较，通常子查询的位置在比较式的右侧示例：123456SELECT * FROM article WHERE uid = (SELECT uid FROM user WHERE status=1 ORDER BY uid DESC LIMIT 1)SELECT * FROM t1 WHERE column1 = (SELECT MAX(column2) FROM t2)SELECT * FROM article AS t WHERE 2 = (SELECT COUNT(*) FROM article WHERE article.uid = t.uid)MySQL 列子查询：指子查询返回的结果集是 N 行一列，该结果通常来自对表的某个字段查询返回。可以使用 = &gt; &lt; &gt;= &lt;= &lt;&gt; 这些操作符对子查询的标量结果进行比较，通常子查询的位置在比较式的右侧可以使用 IN、ANY、SOME 和 ALL 操作符，不能直接使用 = &gt; &lt; &gt;= &lt;= &lt;&gt; 这些比较标量结果的操作符。示例：12345SELECT * FROM article WHERE uid IN(SELECT uid FROM user WHERE status=1)SELECT s1 FROM table1 WHERE s1 &gt; ANY (SELECT s2 FROM table2)SELECT s1 FROM table1 WHERE s1 &gt; ALL (SELECT s2 FROM table2)NOT IN 是 &lt;&gt; ALL 的别名，二者相同。特殊情况:如果 table2 为空表，则 ALL 后的结果为 TRUE；如果子查询返回如 (0,NULL,1) 这种尽管 s1 比返回结果都大，但有空行的结果，则 ALL 后的结果为 UNKNOWN 。注意：对于 table2 空表的情况，下面的语句均返回 NULL：12SELECT s1 FROM table1 WHERE s1 &gt; (SELECT s2 FROM table2)SELECT s1 FROM table1 WHERE s1 &gt; ALL (SELECT MAX(s1) FROM table2)MySQL 行子查询：指子查询返回的结果集是一行 N 列，该子查询的结果通常是对表的某行数据进行查询而返回的结果集。123456例子：SELECT * FROM table1 WHERE (1,2) = (SELECT column1, column2 FROM table2)注：(1,2) 等同于 row(1,2)SELECT * FROM article WHERE (title,content,uid) = (SELECT title,content,uid FROM blog WHERE bid=2)MySQL 表子查询：指子查询返回的结果集是 N 行 N 列的一个表数据。例子：1SELECT * FROM article WHERE (title,content,uid) IN (SELECT title,content,uid FROM blog)三、字查询例举ANY进行子查询any关键词的意思是“对于子查询返回的列中的任何一个数值，如果比较结果为TRUE，就返回TRUE”。好比“10 &gt;any(11, 20, 2, 30)”，由于10&gt;2，所以，该该判断会返回TRUE；只要10与集合中的任意一个进行比较，得到TRUE时，就会返回TRUE。1234567891011select table1.customer_id,city,count(order_id)from table1 join table2on table1.customer_id=table2.customer_idwhere table1.customer_id&lt;&gt;&apos;tx&apos; and table1.customer_id&lt;&gt;&apos;9you&apos;group by customer_idhaving count(order_id) &gt;any (select count(order_id)from table2where customer_id=&apos;tx&apos; or customer_id=&apos;9you&apos;group by customer_id);any的意思比较好明白，直译就是任意一个，只要条件满足任意的一个，就返回TRUE。使用IN进行子查询使用in进行子查询，这个我们在日常写sql的时候是经常遇到的。in的意思就是指定的一个值是否在这个集合中，如何在就返回TRUE；否则就返回FALSE了。in是“=any”的别名，在使用“=any”的地方，我们都可以使用“in”来进行替换。有了in，肯定就有了not in；not in并不是和&lt;&gt;any是同样的意思，not in和&lt;&gt;all是一个意思。使用SOME进行子查询some是any的别名，用的比较少。使用ALL进行子查询all必须与比较操作符一起使用。all的意思是“对于子查询返回的列中的所有值，如果比较结果为TRUE，则返回TRUE”。好比“10 &gt;all(2, 4, 5, 1)”，由于10大于集合中的所有值，所以这条判断就返回TRUE；而如果为“10 &gt;all(20, 3, 2, 1, 4)”，这样的话，由于10小于20，所以该判断就会返回FALSE。&lt;&gt;all的同义词是not in，表示不等于集合中的所有值，这个很容易和&lt;&gt;any搞混，平时多留点心就好了。标量子查询根据子查询返回值的数量，将子查询可以分为标量子查询和多值子查询。在使用比较符进行子查询时，就要求必须是标量子查询；如果是多值子查询时，使用比较符，就会抛出异常。多值子查询与标量子查询对应的就是多值子查询了，多值子查询会返回一列、一行或者一个表，它们组成一个集合。我们一般使用的any、in、all和some等词，将外部查询与子查询的结果进行判断。如果将any、in、all和some等词与标量子查询，就会得到空的结果。独立子查询独立子查询是不依赖外部查询而运行的子查询。什么叫依赖外部查询？先看下面两个sql语句。sql语句1：获得所有hangzhou顾客的订单号。12345678910111213141516select order_idfrom table2where customer_id in (select customer_id from table1 where city=&apos;hangzhou&apos;);sql语句2：获得城市为hangzhou，并且存在订单的用户。select *from table1where city=&apos;hangzhou&apos; and exists (select * from table2 where table1.customer_id=table2.customer_id);上面的两条sql语句，虽然例子举的有点不是很恰当，但是足以说明这里的问题了。对于sql语句1，我们将子查询单独复制出来，也是可以单独执行的，就是子查询与外部查询没有任何关系。对于sql语句2，我们将子查询单独复制出来，就无法单独执行了，由于sql语句2的子查询依赖外部查询的某些字段，这就导致子查询就依赖外部查询，就产生了相关性。对于子查询，很多时候都会考虑到效率的问题。当我们执行一个select语句时，可以加上explain关键字，用来查看查询类型，查询时使用的索引以及其它等等信息。比如这么用：123456explain select order_id from table2 where customer_id in (select customer_id from table1 where city=&apos;hangzhou&apos;);使用独立子查询，如果子查询部分对集合的最大遍历次数为n，外部查询的最大遍历次数为m时，我们可以记为：O(m+n)。而如果使用相关子查询，它的遍历 次数可能会达到O(m+m*n)。可以看到，效率就会成倍的下降；所以，大伙在使用子查询时，一定要考虑到子查询的相关性。相关子查询相关子查询是指引用了外部查询列的子查询，即子查询会对外部查询的每行进行一次计算。但是在MySQL的内部，会进行动态优化，会随着情况的不同会 有所不同。使用相关子查询是最容易出现性能的地方。而关于sql语句的优化，这又是一个非常大的话题了，只能通过实际的经验积累，才能更好的去理解如何进 行优化。EXISTS谓词EXISTS是一个非常牛叉的谓词，它允许数据库高效地检查指定查询是否产生某些行。根据子查询是否返回行，该谓词返回TRUE或FALSE。与其 它谓词和逻辑表达式不同的是，无论输入子查询是否返回行，EXISTS都不会返回UNKNOWN，对于EXISTS来说，UNKNOWN就是FALSE。 还是上面的语句，获得城市为hangzhou，并且存在订单的用户。123456select *from table1where city=&apos;hangzhou&apos; and exists (select * from table2 where table1.customer_id=table2.customer_id);关于IN和EXISTS的主要区别在于三值逻辑的判断上。EXISTS总是返回TRUE或FALSE，而对于IN，除了TRUE、FALSE值外， 还有可能对NULL值返回UNKNOWN。但是在过滤器中，UNKNOWN的处理方式与FALSE相同，因此使用IN与使用EXISTS一样，SQL优化 器会选择相同的执行计划。说到了IN和EXISTS几乎是一样的，但是，就不得不说到NOT IN和NOT EXISTS，对于输入列表中包含NULL值时，NOT EXISTS和NOT IN之间的差异就表现的非常大了。输入列表包含NULL值时，IN总是返回TRUE和UNKNOWN，因此NOT IN就会得到NOT TRUE和NOT UNKNOWN，即FALSE和UNKNOWN。派生表上面也说到了，在子查询返回的值中，也可能返回一个表，如果将子查询返回的虚拟表再次作为FROM子句的输入时，这就子查询的虚拟表就成为了一个派生表。语法结构如下：1FROM (subquery expression) AS derived_table_alias由于派生表是完全的虚拟表，并没有也不可能被物理地具体化。四、子查询优化很多查询中需要使用子查询。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死。子查询可以使查询语 句很灵活，但子查询的执行效率不高。子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句再临时表中查询记录。查询完毕 后，MySQL需要撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。在MySQL中可以使用连接查 询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快。使用连接(JOIN)来代替子查询如：12345678910111213141516171819例子1： SELECT * FROM t1WHERE t1.a1 NOT in (SELECT a2 FROM t2 ) 优化后： SELECT * FROM t1LEFT JOIN t2 ON t1.a1=t2.a2WHERE t2.a2 IS NULL 例子2：SELECT * FROM article WHERE (title,content,uid) IN (SELECT title,content,uid FROM blog) 优化后：SELECT * FROM articleinner join blogon (article.title=blog.title AND article.content=blog.content AND article.uid=blog.uid)不能优化的子查询：mysql不支持子查询合并和聚合函数子查询优化，mariadb对聚合函数子查询进行物化优化；mysql不支持from子句子查询优化，mariadb对from子句子查询进行子查询上拉优化；mysql和mariadb对子查询展开提供有限的支持，如对主键的操作才能进行上拉子查询优化；mysql不支持exists子查询优化，mariadb对exists关联子查询进行半连接优化，对exists非关联子查询没有进一步进行优化；mysql和mariadb不支持not exists子查询优化；mysql和mariadb对in子查询，对满足半连接语义的查询进行半连接优化，再基于代价评估进行优化，两者对半连接的代价评估选择方式有差异；mysql不支持not in子查询优化，mariadb对非关联not in子查询使用物化优化，对关联not in子查询不做优化；mysql和mariadb对&gt;all非关联子查询使用max函数，&lt;all非关联子查询使用min函数，对=all和非关联子查询使用exists优化；对&gt;some和&gt;any非关联子查询使用min函数，对&lt;some和&lt;any非关联子查询使用max函数，=any 和=some子查询使用半连接进行优化，对&gt;some和&gt;any关联子查询以及&lt;some和&lt;any关联子查询只有exists 优化。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.elonchung.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.elonchung.cn/tags/MySQL/"}]},{"title":"hexo使用jenkins自动部署到阿里云","slug":"jenkis","date":"2017-07-01T10:21:52.000Z","updated":"2018-05-03T15:30:19.297Z","comments":true,"path":"2017/07/jenkis/","link":"","permalink":"https://www.elonchung.cn/2017/07/jenkis/","excerpt":"","text":"hexo使用jenkins自动部署到阿里云","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"}]},{"title":"HTTP协议详解之消息报头篇","slug":"http-msg","date":"2017-06-30T08:54:28.000Z","updated":"2018-05-05T04:38:49.527Z","comments":true,"path":"2017/06/http-msg/","link":"","permalink":"https://www.elonchung.cn/2017/06/http-msg/","excerpt":"","text":"HTTP协议详解之消息报头篇HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。eg：Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cacheDate普通报头域表示消息产生的日期和时间Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。请求报头举例：GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,/ (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/“80b1a4c018f3c41:8317” (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF)响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.elonchung.cn/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.elonchung.cn/tags/HTTP/"}]},{"title":"轻松理解HTTP基本知识","slug":"http","date":"2017-06-30T03:34:50.000Z","updated":"2018-05-05T04:59:24.149Z","comments":true,"path":"2017/06/http/","link":"","permalink":"https://www.elonchung.cn/2017/06/http/","excerpt":"","text":"引言HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议的特点支持客户/服务器模式。简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。HTTP协议的应用场景Web service、WSDL、小偷程序、采集程序、爬虫程序、socket、防盗链http协议执行的粗糙流程chrome搜索自身的DNS缓存搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效，缓存时间大概只有一分钟）读取本地host文件浏览器发起一个DNS 的一个系统调用宽带运营商服务器查询本地缓存运营商服务器发起一个迭代DNS解析请求1. 运营商服务器把结果返回操作系统内核同时缓存起来 2. 操作系统内核把结果返回浏览器 3. 最终浏览器那桐了xxx.abc.com对应的ip地址 浏览器获得域名对应的ip地址后，发起http“三次握手”TCP/IP连接建立起来，浏览器就可以向服务器发送http请求了使用了比如说，用http的get方式请求一个根域里的一个域名，协议可以采用HTTP 1.1 的一个协议服务器端接受到了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器，如果是网站的页面就会把完整的HTML页面代码返回给浏览器。浏览器拿到了网站的完整的HTML页面代码，在解析和渲染这个页面的时候，里面的JS,CSS,图片静态资源，他们同样也是一个HTTP请求，同需要经过上面的主要七个步骤。浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给用户http协议的组成部分HTTP协议主要可以拆分两大模块 “请求”与“响应”， 他们都具备 HTTP头 和 正文信息详细的消息报头解释可跳步《HTTP协议详解之消息报头篇》客户端 请求报文信息报文首部(HTTP头)请求行：包栝请求方法，URL和HTTP协议版本请求首部字段、通用首部字段、实体首部字段、其他（包括请求的各种条件和属性【值键值对】)空行（CR+LF）报文主体（正文信息【即用户提交的表单数据】）服务端 响应报文信息报文首部(HTTP头)状态行：包括响应结果的HTTP协议版本、状态码、状态描述响应首部字段、通用首部字段、实体首部字段、其他（包括响应的各种条件和属性【值键值对】)空行（CR+LF）报文主体（正文信息【即服务端返回的数据】）telnet执行的代码案例1234567891011121314151617181920POST /test.php HTTP/1.1 (CRLF) &lt;请求行&gt; host:localhost (CRLF) &lt;请求条件和属性&gt; Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Thu,08 Mar 201507:17:51 GMT (CRLF)If-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)Connection:Keep-Alive (CRLF)(CRLF)v:1.0 &lt;请求报文主体&gt;HTTP/1.1 200 OK &lt;状态行&gt; Server: nginx &lt;响应条件和属性&gt; Date: Thu,08 Mar 201507:17:52 GMTConnection: Keep-Alive Content-Length: 23330Content-Type: text/htmlCache-control: privatehttp test &lt;响应报文主体&gt;http请求方法请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URI作为其标识DELETE 请求服务器删除Request-URI所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求响应状态码状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.elonchung.cn/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.elonchung.cn/tags/HTTP/"}]},{"title":"Hexo利用Github分支在不同电脑上写博客","slug":"hexo-branch","date":"2017-06-30T00:49:53.000Z","updated":"2018-05-05T04:57:44.292Z","comments":true,"path":"2017/06/hexo-branch/","link":"","permalink":"https://www.elonchung.cn/2017/06/hexo-branch/","excerpt":"","text":"Hexo是一个很好的开源博客框架，支持Markdown的写作方式，并且可以与Github Page协作轻松搭建博客，非常适合展示性的个人博客。Hexo通过将Markdown文件编译成html文件，然后将html文件直接部署到网站上，所以被称作静态博客，因为直接就是访问的最终的html文件，不会有PHP那样的中间处理，所以对浏览器来讲会比较快。当然，这种方式也有缺点，一是Github毕竟部署在国外，而且访问偶尔会抽风，所以速度无法保障；二是所有的静态页面由于都需要保存在github里的自己名下的网站同名项目仓库内，所以如果项目仓库是public的，那么所有人都会看到你的网站代码， 这个其实应该也没有关系吧！！！hexo都是开源的，而且静态博客是编译后的，框架和主题都是用的别人开源出来的，但博客写了不就是让别人看的？所以应该真的无所谓。。。如果你实在不想让别人看到你的md原件，那么就不要使用本文所说的同一个项目的分支啦，就去新建一个项目来单独保存源码文件吧，并且把这个项目设为priviate的，要花钱的哦，这样别人就看不到啦。。。下面进入正题， 利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客Github Page这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 dxjia.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。新建hexo分支仓库建好之后，都是默认一个 master 分支的，Github page要求你的网站文件必须存放在这个 master 分支上，这个没得选；所以我们需要新建另外一个分支来保存我们的hexo原始文件；设置默认分支因为我们写博客更多的是更新这个分支，网站文件所在的 master 分支则由 hexo d 命令发布文章的时候进行推送，所以我们将 hexo分支设置为默认分支，这样我们在新的电脑环境下 git clone 该仓库时，自动切到 hexo`分支。配置hexo deploy参数为了保证 hexo d 命令可以正确部署到 master 分支，在hexo 的配置文件 _config.yml 文件中配置参数如下：deploy:type: gitrepo: https://github.com/dxjia/dxjia.github.io.gitbranch: masterhexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法 hexo d ，使用下面的命令安装git deployer插件后重试即可。npm install hexo-deployer-git –save修改推送到hexo分支上一步的deploy参数正确配置后，文章写完使用 hexo g -d 命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io 仓库的 master 分支上，这时候通过浏览器访问 http://username.github.io 就可以看到你的博客页面里。网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到 hexo 分支上去git add .git commit -m “change description”git push origin hexo这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。日常写博客有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。已有环境如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。在你的仓库目录下右键’git bash shell’，起来bash命令行，然后git pull这样你的状态就更新了，之后就是 hexo 命令写文章啦。。。写完 hexo g -d 部署好后，使用git add .git commit -m “change description”git push origin hexo推送上去。新的环境到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。git clone https://github.com/dxjia/dxjia.github.io.gitcd dxjia.github.ionpm install hexonpm installnpm install hexo-deployer-git –save之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去。。。","categories":[{"name":"Git","slug":"Git","permalink":"https://www.elonchung.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.elonchung.cn/tags/Git/"}]},{"title":"Markdown","slug":"markdown","date":"2017-06-29T08:54:50.000Z","updated":"2018-05-03T15:24:01.307Z","comments":true,"path":"2017/06/markdown/","link":"","permalink":"https://www.elonchung.cn/2017/06/markdown/","excerpt":"","text":"Markdown 语法使用手册","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.elonchung.cn/tags/Markdown/"}]},{"title":"hexo使用","slug":"hexo","date":"2017-06-29T05:21:52.000Z","updated":"2018-05-05T04:59:04.761Z","comments":true,"path":"2017/06/hexo/","link":"","permalink":"https://www.elonchung.cn/2017/06/hexo/","excerpt":"","text":"自己也算是摸爬滚打搭建成功，然后自己再重新安装部署一遍，把完整步骤分享给大家，同时最后有一些连接，如果我的步骤不行，大家可以参考其他人的（这个有点花费时间，大家提前有个心理准备 - _-）安装hexo安装要求（以下为下载链接 安装步骤省略 ）：下载安装Git下载安装node.js1、创建文件夹（我的是在E盘创建的Hexo）利用 npm 命令即可安装。在文件夹空白位置点击鼠标右键，选择Git Bash在电脑任意位置右键2、输入命令：1npm install -g hexo注意：-g是指全局安装hexo--save是指项目独立安装hexo。初始化Hexo与使用1、初始化成功后生成的一些列文件在Hexo文件下，右键运行Git Bash，输入命令：1hexo init2、获取主题next ，修改基础配置其中可以在这里浏览更多主题，然后在Hexo文件夹下 Git Bash输入命令：1git clone https://github.com/iissnan/hexo-theme-nextthemes/next（next为主题名字），来获得更多主题下载成功（如果需要更改主题，请在_cofig.yml修改theme）在_config.yml，进行基础配置3、本地浏览博客分别输入 如下命令：123hexo g hexo s这里有更多hexo常用命令在浏览器输入：localhost：4000 ，就可以进行访问，效果如下：效果图4、写文章在E:\\Hexo\\source_posts文件下，新建.md文件就可以写文章新建hexo.md文件123456789---title: hexo使用date: 2018-04-09 13:21:52categories: - 小公举 - 博客tags:- 小公举---浏览效果部署到Github上1、申请Github账号，（注意别忘了进行账号邮箱验证）2、new repository3、在_config.yml进行配置（注意：要保存）4、安装hexo-deployer-git自动部署发布工具在Hexo文件夹下 Git Bash1npm instal lhexo-deployer-git --save5、发布到Github输入如下命令：1234567清理缓存文件hexo clean构建及部署到github上hexo g -d或者hexo d -g第一次发布需要验证github账号发布完成在仓库中我们也可以看到6、如需要验证ssh浏览这个教程7、测试访问在浏览器输入：https://zhongweixiang.github.io/","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.elonchung.cn/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://www.elonchung.cn/tags/git/"}]},{"title":"学习资源","slug":"phpstudy","date":"2017-06-28T05:10:09.000Z","updated":"2018-05-05T04:45:41.404Z","comments":true,"path":"2017/06/phpstudy/","link":"","permalink":"https://www.elonchung.cn/2017/06/phpstudy/","excerpt":"","text":"PHP学习资料区yii2干货集各类技术干货（国人）各类技术干货（英文）大前端工具集","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://www.elonchung.cn/categories/学习资料/"}],"tags":[{"name":"资料","slug":"资料","permalink":"https://www.elonchung.cn/tags/资料/"}]},{"title":"大前端工具集——收藏","slug":"front-tool","date":"2017-06-27T17:16:28.000Z","updated":"2020-07-21T06:27:01.937Z","comments":true,"path":"2017/06/front-tool/","link":"","permalink":"https://www.elonchung.cn/2017/06/front-tool/","excerpt":"","text":"大前端工具集本篇文章记录了一枚程序猿的百宝箱。PS：每个分类的都按照推荐的先后排列。主要内容是一些使用过的库、工具、套路或关注的前端组织等等，反正用 前端瑞士军刀 来总结这篇文章再合适不过鸟。前端组织/前端博客虽混过外企俩家，但劳资英文这项的技能点还是灰色的…so，俺关注的站点主要以中文为主GitHub - 没 Git 都不好意思面基有木有！！！MDN - 无数的资源再等着你探索，追标准和新特性肯定得关注的网站Awesomes.cn - 国人维护的前端资源库，深度对接到 Github，分类和展现清晰，值得收藏如何跟上前端开发的最新前沿 - RT，不解释慕课 - 大量的在线计算机课程。 虽然初、中级居多，但是不乏有巨作值得细细品尝阮一峰 - 关注多年，拜读其 ES6 系列。虽网传靠写书进鸟阿里，但博客内容确实够丰富W3Cplus - 大漠(《图解 CSS3》作者)在国内的影响力杠杠的，Sass 专家级淘宝前端团队 - 内容涵盖 Web 和 Node，要深度游深度，要广度有广度奇舞团博客 - 坚持是最宝贵的，别人的奇舞周刊早已经过百期了百度 FEX - 代表作 FIS、UEditor、WebUploader、KityMinder腾讯全端 AlloyTeam - 腾讯 Web 前端团队，博客真的有点丑…粉丝日志 for 张丹 - 大爱作者写的 Node 系列张鑫旭 - 成名多年的、高产的前端大湿，CSS猛人博客搭建hexo - 快速、简洁且高效的博客框架jekyll - 将纯文本转化为静态网站和博客GithubPages - 免费的静态站点。配合着 hexo 或 jekyll 的模板，分分搭建出一套炫酷的个人博客Tumblr - 轻博客的祖师爷，各种各样的主题感觉不错Wordpress - 这玩意古老到都不想介绍使用 hexo/jekyll + GitPage，前端搭建静态博客那是相当 easy。用 Markdown 写文章做记录，再 push 到 Git 上，分分钟高大上有木有HTML/CSSHEAD - 最全的 &amp;lt;head&amp;gt; 列表，真心佩服这种偏执的整理能力MetroUI - 好看好用，重点是样式特别、个性LoadersCSS - 用 CSS 技术实现 loading 动画； 补一句，想熟悉、理解 keyframes、animation、transform、transition 的童鞋可以直接去读其源码(只有千把行代码)，读完就算出师鸟:)WeUI - 一套同微信原生视觉体验一致的基础样式库 为微信 Web 开发量身设计，令用户的使用感知更加统一PostCSS - 最近才知道大名鼎鼎Autoprefixer是其插件 推荐大漠的文章《PostCSS深入学习》，有关 PostCSS 不是什么？PostCSS 是什么？PostCSS 可以做什么等等问题，文章里面有答案CSSgram - 图片滤镜库，终于可以用 CSS 在 web 上实现滤镜的效果鸟 IE不支持，不过新的移动设备支持没问题 Can I UseHINT.css - 一款非常小巧的提示框效果Balloon.css| |同上，一款非常小巧的提示框效果Hover.css - 很多鼠标 Hover 态的效果，可以给产品学习一下:)Cursor - 记录各浏览器对Cursor的支持情况csscss - 用于检查 CSS 代码冗余purecss - 小巧的响应式 CSS 库，Yahoo!出品hamburgers - 简单的动画库，让 Click(or Tap) 变得美妙cssmatic - 一个帮忙调试CSS效果的工具浏览端 JSrequirejs - JS模块化是构建复杂项目的第一步 中文学习文档奉上：RequireJS 中文网ECharts - 好用，最关键的是支持的图表展示非常之多，强烈推荐Swiper - 强大的 Slider 库 其实这类效果库非常多，但文档能那么专业的就很少鸟babel - ES6 用起来。这个插件可以让我们用新的 标准/提案 写 JavaScript 代码，然后再向下 转换编译，最终生成随处可用的 JavaScript 代码。中文文档奉上《babel-handbook》fullPage - 非常好用的全屏滑动库，看 Demo 就明白PhotoSwipe - 偶常用的 js 库 官网上有这么一句很关键、重要”no dependencies”Vuejs - 比较喜欢其作者… 所以劳资正在看源码学习学习favico.js - 动态改变浏览器标签栏中的网站图标，非常好玩ant.design - 蚂蚁金服搞的良心项目，文档美好的令人发指 样式优雅，强烈推荐内部系统尝试此库highlightjs - 代码高亮库，支持非常多的语言daterangepicker - 时间选择插件的不二选择，基于 Bootstrap 和 Moment.jsnodePPT - 前同事三水的大作，好用必须得支持:) 用 Markdown 写 PPT，还可以 HTML 混排，上手飞快Sortable - 拖拽神器，用了就知道toastr - 信息提示的库，推荐的原因是卖相好、功能强大 demopeity.js - jQuery的图表插件，特别cute，感觉萌萌哒 将HTML转换成一个小的&amp;lt;svg&amp;gt;饼图、圆环图、折线图等等emojify.js - 能够将emoji关键词转换为emoji图片的JS插件 可以快速的为你的网站提供emoji表情支持Highcharts| |Highcharts 中文网，又是一个图表库 确实功能强大，但是觉得不好看… PS：官网就做的不好看，脏脏的赶脚NProgress - 使页面加载时有更好的loading效果Noticejs - 一个简单的通知库，木有依赖onepage-scroll - 依赖 jQuery 的单页滚动库，和 fullPage 类似videojs - 当下视频需求都用上&amp;lt;video&amp;gt;鸟 样式和交互统一的问题交给 videojs 搞定:)clipboard - 仅 2KB 大小，搞定剪贴板功能，屌不屌~ 但是，Safari 不支持…impress.js - 用来写 PPT 不错，偶也曾为其写过一篇impress.js 初体验Cropper - 国人开发的图片裁剪库Swiper/PhotoSwipe/fullPage 有这仨库，微信里常见的 H5 页完全不是问题哒Project Buildpm2 - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 Forever 的进阶库，想了解的可以看这篇文章《拥抱PM2》Webpack - 项目构建工具，由于过于复杂和太强大，所以劳资还没去深入研究。Gulp - Gulp 是基于 Node 实现 Web 前端自动化开发的工具。 俺总结了篇《gulp使用小结》，推荐您阅读:)Bower - 前端项目的包管理其实是件复杂的事 谁谁谁依赖谁谁谁，谁谁谁依赖谁谁谁的某个版本…卧槽 Bower 就是搞定这件事儿的，亲爹是 Twitter 推荐篇 Bower 的中文文章：《bower 解决 js 的依赖管理》Grunt - 和 Gulp 类似，都是项目构建的常见选择 对比这俩的文章可谓不少，推荐篇《Gulp vs Grunt》 英盲又想看文档，可以去Grunt 中文网FIS - 度厂出品的前端构建工具 文档清晰，功能强大，推荐了解和使用Gitlab CI - 一套基于Gitlab的持续集成服务Gulp + Webpack 的使用套路参考: learning-gulpGulp 资料收集：use-gulp推荐篇与 Webpack 相关的文章《CSS Modules》Webpack 用起来吼吼：webpack-howtoNode Package作为一名大前端甚至是多端，Node 绝逼是必备的一块有关 Node 的学习资料，请访问这里介绍些有特色且前端有必要知道的包anywhere - 随时随地将你的当前目录变成一个静态文件服务器的根目录supervisor - 监控 Node 代码，自动重启。 A supervisor program for running nodejs programsnodemon - 监控 Node 代码，自动重启。 Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.pm2 - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 Forever 的进阶库，想了解的可以看这篇文章《拥抱PM2》async - 一个流程控制工具包，提供直接而强大的异步功能lodash - JS 工具库 Underscore.js的一个 fork 发展而来socket.io - 预计 Node 的实时框架 聊天室、页游等对实时性有高要求的较适用Mongoose - 让 NodeJS 更容易操作 Mongodb 数据库； 附上一篇Mongoose 学习参考文档CNPM - 淘宝 NPM 镜像，提供了 NPM 同步的服务 当然可不仅仅这样，利用 CNPM 可以打造企业/个人私有的 NPM 服务 推荐篇搭建私有NPM的文章：《CNPM搭建私有的NPM服务》koa - 玩 Node 都知道 express，但使用 koa 的就少很多，门槛比 Ex 稍高 通过 generator 避免繁琐的回调函数嵌套，强烈推崇 官方的文章教程Shipit - 一个强大的自动化部署工具。 shipit 很多地方非常类似 gulp，他们的核心都是任务系统。node-inspector - Node 调试工具，使用起来跟 Chrome 的 JS 调试器很相似winston - Node 服务最流行的日志库之一co - 用 generator 写法让异步代码同步thenify-all - 把异步的方法变成 Promise 的 Promisifies all the selected functions in an objectPhantomJS - 一般用来做抓取截图和无界面测试 也可以用来操作 DOM 和网络监测，很好玩的库 Quick Startava - 偶是应TJ大神推荐而得之的 ava 未来的测试运行器Mocha - Node 里最常用的测试框架； 它支持多种 Node 的 Assert libs； 同时支持异步和同步的测试，同时支持多种方式导出结果； 也支持直接在 browser 上跑 JS 代码测试。koa-validate - koa 的校验库 可以非常方便的对 queryString 或 postBody 的信息进行验证line-reader - 基于steam的按行读文件，偶处理日志时用哒 要不实现一个按行读文件，又得 steam、 又得 chunk，还是比较麻烦的everyauth| |OAuth 的集成解决方案shelljs - 写 Node 时难免需要用 shell 去操作些神马 shelljs 是基于 Node 的 shell 工具，API 及其简单hashids - 看名称就懂，给 userid 加解密用的node-pool - 让 Node 有连接池的概念colors - 花俏的小工具 让打印console.log时有更好的展示样式n - 控制Node的版本，想升级一行代码搞定supervisor 和 nodemon 这俩都是监控 Node 代码，使得每次修改代码后会，开发 Node 程序必备以上库俺都有使用过，甚至有不少都是项目开发中、各种特定场景下必用的，有任何使用问题欢迎沟通哈:)Node Project_暂无_精选阅读前端技术2015D2前端论坛 - Node方向非常值得看，有干货，相信东哥推荐哈前端开发规范手册 - 此手册主要实现的目标：代码一致性和最佳实践《babel-handbook》 - 可以用新的规范(如 ES6)写代码，经过 babel 编译后生成没有兼容问题的代码ECMAScript 6入门 - 阮一峰大神所著，一本开源的JS教程 全面介绍 ECMAScript 6新引入的语法特性ReactNative 中文版 - 翻译自官方的中文文档ReactWebpackCookBook | |此书会引导读者是进入React和Webpack的世界。 俩都是非常前沿的技术，同时使用会更有趣。ReactNative 学习指南 - 新玩意层出不穷… 对于能持续学习的童鞋，这是个美好的时代HTML/CSS 编码规范 - 编写灵活、稳定、高质量的HTML和CSS代码的规范移动前端入门 - 入门价值高，移动方向常见问题的较好总结GulpBook - Gulp 是基于 Node 实现 Web 前端自动化开发的工具Node 学习资料Node.js 中文资料导航 - Node 的中文资料导航，start1300+从零开始 NodeJS 系列文章 - 基本上每一篇都看过，强烈推荐Node.js 包教不包会 - 值得阅读，看完绝不用买书鸟七天学会 NodeJS - 劳资还没看，不过看目录还不错:)Style Guide - 这是一份关于如何写出一致且美观的 Node 代码的风格指南koa实战 - “明河出品”这四字已经说明一切。PS：正在连载中stream-handbook - 如果学习 NodeJS，那么流一定是需要掌握的概念前端面试在 LinkedIn 做面试官的故事 - 非面试题，介绍 LinkedIn 的面试过程 文章有很多中肯的建议和想法，推荐阅读大漠：写给前端面试者 - 这篇文章不涉及任何的面试题 大漠与大家聊聊面试者与被面者之间的感受…前端面试题 - Git 上非常火的前端面试题，start17k+前端面经 - 主要内容是些前端面试笔试题和面试套路，值得阅读其他技术MongoDB 极简实践入门 - 入门推荐的套路，非常浅显易懂Mac 设置指南 - Mac 使用必看 尤其适合 偏执狂/强迫症 患者:)Markdown 资料 - 简单看些语法入门，快速用起来工具/软件WebCanIuse - 前端必备；查看浏览器对各种新特性的兼容情况overapi - 最全的开发人员在线速查手册百度脑图 - 非常方便的思维导图工具ProcessOn - 和百度脑图的功能类似，脑图工具。VimAwesome - Vim 插件集合，Vim 党必备Tower - 小而美的多人协同工具。 不光只有 Web 版，还有 iPhone、iPad、Android、微信版。Slides - 一个所见即所得的 WebPPT 编辑器，非常推荐faviconer.co - 一个所见即所得的icon生成器，很好用smallpdf - 提供各种格式和 PDF 互相转换Cmd Markdown - 好用的 Web 版 Markdown 编辑器StackEdit - 又是一款 Web 版 Markdown 编辑器墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。htm2pdf| |HTML to PDFSpeaker Deck - 在线的演讲稿展示平台RunJS - 在线编辑、展示、分享、交流你的 JavaScript 代码Bootswatch - Bootstrap 的免费模板AdminLTE - 又是一个 Bootstrap 的免费管理后台APP以下列表中的 APP 都是不区分系统平台的印象笔记 - 免费账号完全够用，跨平台跨终端的记录软件365日历 - 首先肯定比系统自带的日历强大，要不推荐个蛋蛋 俺一般用来搞目标管理，比如学习计划和工作计划 生活中会订阅演唱会、电影首映的信息多看阅读 - kindle 确实好，但是懒得随身带着 多看还算不错，书较多且偶尔有特价比较爽Surge - 非免费 牛逼的网络开发与调试工具，前端必备Monkey - Monkey 是 iPhone 上一个 GitHub 第三方客户端。 展示 GitHub 上的开发者的排名，以及仓库的排名Mac对于美好事务的追求无论何时都不算晚，前年公司给配了台 Mac 用做测试开发机，于是开始在 Mac 下办公。 Windows？ 回不去鸟…Homebrew - 没它程序猿没法好好干活… Homebrew使OS X更完美。 使用gem来安装gems、用brew来搞定那些依赖包iTerm2 - Mac 终端功能少又不好看，iTerm2 可以解救你~ 推荐篇文章：《让你的命令行丰富多彩》BrowseShot - 偶正在使用的网页截图工具，强烈推荐BeyondCompare - 在Windows下就开始用了 比对文件和文件夹杠杠好使，Merge必备工具CheatSheet - 能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘Sequel Pro - 免费好用的Mysql工具LICEcap - 屏幕录制工具，支持导出 GIF 动画图片格式 轻量级、使用简单，录制过程中可以改变录屏范围Manico - 快捷启动和切换 APP 的工具，高效的第一步 AppStore 上收费，不过可以免费试用WebStorm - 功能超强的前端 IDE，不多介绍，谁用谁知道 PS：貌似俺插件装多了，用着卡卡的，风扇呼呼转…Atom - 2015 年 7 月之前，在桌面环境下我最喜欢的编辑器是 Sublime。 但之后就是 Atom，俺也专门为它写了篇使用纪要马克鳗 - MarkMan，非常强大好用的标注、测量工具。 日常工作免费版就完全可以满足，强烈推荐Wireshark - 说实话，Mac 下木有 Fiddler 挺不习惯，不过在有更强大的替代品SourceTree - 一款好用的的 Git 客户端工具，重点是支持中文:)focus booster - 因为比较在意时间管理，所以这软件是俺工作时间的必备之物Mou - 我曾使用过的 mk 编辑器。原本准备去掉这个推荐，但是我想让大家了解下这个有意思的事情：《一年了，那个闻名遐迩的 Mou 你还记得吗？》Linuxoh-my-zsh - 终端党 必用的好工具，强烈推荐tree - linux 以树状图逐级列出目录的内容oneapm - 强大的运维工具，提供多种监控客户端； 有采集、分析、展示等一套功能； PS：我这用了服务器监控(免费哦)httpie - 一个 CLI 中的 HTTP 客户端 用法简单、易读Chrome 浏览器插件Chrome 应用商店必定是需要翻墙的哈。以下插件都是俺多年积累淘出来的，按照俺推荐的强度自上向下展示，且大多数插件就是偶工作和生活必备，希望能对大家有用。后续如有新发现好插件，偶也会及时更新哒Postman - POST 接口调试终结者，异常强大的接口调试工具，稍稍有一点学习成本，推荐之JSONView - 就是一个 JSON 的查看工具，可以很方便的展示数据，麻麻再也不用担心偶调试接口啦。PS：同类插件有不少，所以用的开心就行二维码生成器 - RT，不多说明了。PS：这FF早已经自带生成二维码工具了，Chrome 还得装插件才行，任性…Eye Dropper 前端必备的颜色提取神器，操作简单容易上手Page Ruler 前端必备的尺子。计算页面元素间距、位置等信息的时候，你就知道它的好了，无脑上手，你值得拥有FireShot 可以截取整个网页、部分页面，然后支持导出为各种格式。俺微博上发的网页全景图都是靠这个插件截取的Infinity - 好不好用有点见仁见智了，但是我个人比较喜欢。使用后会让你的 新标签页 耳目一新，有漂亮的背景和各种常用的功能，比如地图、天气、Gmail、Chrome商店等等。当然，在这个插件的设置中还可以设置壁纸、动画效果等等Momentum 同样也是 新标签页 的插件，但是不管是视觉上(高清大图)还是功能上，都比 Infinity 高大上不少，Setting 里面有不少设置和快捷键，都很好上手的。Infinity胜在中文和直观，Momentum胜在视觉冲击。俺基本上这俩款看心情换着用，所以希望你也都能喜欢:)Octotree - 在浏览器左侧展示 Github 项目的文件导航，使目录结构一目了然，而且我们国内 Git 的访问速度又不稳定，用这个工具也就很提效率了。对经常使用 Github 的同学强烈推荐BuiltWith / wappalyzer / |Chrome Sniffer Plus - 几款超强的网站分析工具，可以给出网站非常多的技术栈信息。大到 Web Servers、服务端的 Frameworks 或 JS 框架，小到 meta、编码格式甚至 Analytics，非常推荐Adblock Plus 非常非常有名的免费的过滤广告的插件。PS：广告屏蔽这个见仁见智，其实俺个人还是比较接受一些个性化推荐的广告GitPlug - 在 Git 项目页中嵌入有关的图表信息，直观的展示当前项目的 Star Trend，能方便看到当前这个开源项目的发起时间，火爆趋势；对比较知名的项目还有相关的 News 展示补充：翻墙代理的插件偶没使用，偶手机和电脑的翻墙都是配的 Surge 无脑搞定，不过翻墙代理插件推荐Proxy SwitchySharp，熊掌公司里大多用的都是它日常开发相关的插件就以上这些，还有几款如知乎的插件、购物插件等这类与开发效率不沾边的，俺就不这上头列了哈GitGit 教程-廖雪峰 - 俺有看过不少 Git 的文章，确实这个系列是最通俗易懂的GitAwards - Git 工具，可以查看 Git 排名Git 速查 - 分类清晰的速查表Git 简明指南 - 入门Git的简明指南，木有高深内容:)Git 学习资料整理| |内容包括很多 Git 的相关资料，star 1200+GitHub 漫游指南 - 一篇还算不错的 Git 学习总结，就是乱了点… 我理解作者_漫游_的意思是漫无目的想到哪写到哪~ 看到作者为鸟达成 Git 连击的成就，也是蛮拼的:)数据端Mongoose - 让 NodeJS 更容易操作 Mongodb 数据库。 附上一篇Mongoose 学习参考文档设计/交互作为负责最终效果呈现的前端工程师，多少得了解些 设计和交互 的，这也是为什么 fetool 会单独的存在这一章…当然话又说回来了，偶毕业的第一份工作是设计:)站酷 - 里面好东西太多，俺当年真没少再上面淘素材UI中国 - 光听名字就知道有多高大上鸟:)速查手册RT，这篇都是些文档或者API，一般这类东西都在大家浏览器的书签内，偶这也列一下大前端常用的手册地址HEAD - 最全的 &amp;lt;head&amp;gt; 列表，真心佩服这种偏执的整理能力百度CDN公共库 - 基本常见的库都收录拉，搞 demo 的时候特方便HTML 和 CSS 代码规范 - 编写灵活、稳定、高质量的 HTML 和 CSS 代码的规范Linux命令中文手册 - 木有系统的好好学习 Linux，所以命令更不熟悉 真羡慕那些CLI玩的飞起的:)Git 速查 - 分类清晰的速查表jQueryAPI 1.11.3 - ZeptoAPI 基本和 jQuery 一样，所以看一份就好CSS3 - CSS3 的在线手册Express API - 中文手册:) 4.x和3.x都有CI用户指南 - 一个轻量级的 PHP 框架用户指南 推荐指数低的原因是劳资PHP比较弱，囧Yaf - 鸟哥(惠新宸)所写的 PHP 框架 推荐指数低的原因同上…###杂七杂八放些开发中较有用的杂物在这儿租房要点 - 适用于北上广深杭，大城市打拼租房确实是硬伤QQ 群规 - 突然某天，有个 QQ 群让我加群 原本我是拒绝的，但当我看完这篇 QQ 群规后… 劳资真的被感动到了，太牛逼、够专业！ 最后，我默默加群鸟:).gitignore 文件 - 介绍不同语言项目的 gitignore 模板程序员如何优雅的挣零花钱？ - 中肯的文章，如果读完能有些许收获，那么恭喜你git-draw - 黑魔法，可以修改自己 Git 上的 ContributionsGitBook - 写记录的好地方Codebabes - 学编程的网站。 重点是每通过一个测试，尼玛对应的妞会脱一件衣服… PS：要翻墙哦~emailframe - 邮件展示确实比较坑，建议有需要的收藏ReadmeSample| |项目高大上的第一步就是包装，所以来看看 README 的书写套路吧 PS：劳资怎么这么无聊…前端炫技-炫酷狂拽叼炸天站点windows93 - 模拟 Win93 桌面，思路、体验和整体效果比较有意思GeekTyper - 好玩又具有 Geek 精神的网站，虽然创建的目的是个恶作剧 PS：网站需要翻墙2016.makemepulse.com - 帅哭了。请使用现代浏览器打开前端技能栈 - 好玩的前端技能栈展示Mapbox - 非常叼的开源项目，有方便的 JSAPI(还有 SDK)。 不过免费版只能浅尝，流量有限。 PS：网站需要翻墙Clark Duvall - 一枚歪果仁的个人 blog，范儿叼叼的SuperScrollorama - 好玩好看的动画库，链接是 SuperScrollorama 的展示页parallax.js - 一个视差引擎的官网，在电脑和手机上都有很好的体验CSS字母 - 用 CSS 实现英文字母，叼叼的墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。小结背景俺算个比较能自我总结的码农，所以偶尔喜欢写点东西做些记录或者自我熏陶陶醉一下。可写着写着发现Evernote里面的东西太尼玛多(乱)了，于是想着把一些技术相关的资料都整理整理，都丢到Git上沉淀下来。 这样Evernote就可以只需要记录些偏生活方便的，看着清爽一些…所以，这篇记录其实只是为偶自己而写，确信以后也一直会这样~~~说说目标其实与这篇记录类似的文章太多鸟，俺也不愿意成为一个单纯的收集资料，分享资料的这么个东西。我希望 fetool 能更生动、更个性，最好能更另类点，对于每样工具的思考和解析更多点，吐槽也必须有理有据，然后再配上劳资收集的 low 图，完美！希望通过不停的完善这篇记录，能Push劳资多了解业内的新玩具和新创意，然后围绕这些新东西，客观的再写点好东西，比如文章、资料、开源项目这些，让其他伙伴们少走弯路或学的更顺畅点儿所以劳资对自己的要求是：这篇记录里列出的每样东西，自己都得的去了解、去尝试，然后再列出来。 能举一反三最好，如果达不到至少也能清楚的认识：列出来的这玩意对程序员有没有卵用，解决了啥痛点。TODO继续完善和扩充内容“备注/说明”这一栏不够犀利，希望再多加入自己的理解、点评、吐槽，让这篇记录更犀利和生动支持导出多种格式，如.pdf、.epub、.mobi等后续看看如果有必要，可以单独搞个页面，优化下阅读和展示效果【转载】 原文地址：http://www.fefork.com/fetool/","categories":[{"name":"前端","slug":"前端","permalink":"https://www.elonchung.cn/categories/前端/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"},{"name":"前端","slug":"前端","permalink":"https://www.elonchung.cn/tags/前端/"}]},{"title":"58到家数据库30条军规解读","slug":"jungui","date":"2017-03-28T03:53:17.000Z","updated":"2018-05-05T04:40:37.177Z","comments":true,"path":"2017/03/jungui/","link":"","permalink":"https://www.elonchung.cn/2017/03/jungui/","excerpt":"","text":"58到家数据库30条军规解读军规适用场景：并发量大、数据量大的互联网业务军规：介绍内容解读：讲解原因，解读比军规更重要一、基础规范必须使用InnoDB存储引擎解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高必须使用UTF8字符集解读：万国码，无需转码，无乱码风险，节省空间数据表、数据字段必须加入中文注释解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的禁止使用存储过程、视图、触发器、Event解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧禁止存储大文件或者大照片解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好二、命名规范只允许使用内网域名，而不是ip连接数据库线上环境、开发环境、测试环境数据库内网域名遵循命名规范业务名称：xxx线上环境：dj.xxx.db开发环境：dj.xxx.rdb测试环境：dj.xxx.tdb从库在名称后加-s标识，备库在名称后加-ss标识线上从库：dj.xxx-s.db线上备库：dj.xxx-sss.db库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx三、表设计规范单实例表数目必须小于500单表列数目必须小于30表必须有主键，例如自增主键解读：a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率c） 无主键的表删除，在row模式的主从架构，会导致备库夯住禁止使用外键，如果有外键完整性约束，需要应用程序控制解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先四、字段设计规范必须把字段定义为NOT NULL并且提供默认值解读：a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录禁止使用TEXT、BLOB类型解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能禁止使用小数存储货币解读：使用整数吧，小数容易导致钱对不上必须使用varchar(20)存储手机号解读：a）涉及到区号或者国家代号，可能出现+-()b）手机号会去做数学运算么？c）varchar可以支持模糊查询，例如：like“138%”禁止使用ENUM，可使用TINYINT代替解读：a）增加新的ENUM值要做DDL操作b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？五、索引设计规范单表索引建议控制在5个以内单索引字段数不允许超过5个解读：字段超过5个时，实际已经起不到有效过滤数据的作用了禁止在更新十分频繁、区分度不高的属性上建立索引解读：a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似建立组合索引，必须把区分度高的字段放在前面解读：能够更加有效的过滤数据六、SQL使用规范禁止使用SELECT *，只获取必要的字段，需要显示说明列属性解读：a）读取不需要的列会增加CPU、IO、NET消耗b）不能有效的利用覆盖索引c）使用SELECT *容易在增加或者删除字段后出现程序BUG禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性解读：容易在增加或者删除字段后出现程序BUG禁止使用属性隐式转换解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）禁止在WHERE条件的属性上使用函数或者表达式解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)禁止负向查询，以及%开头的模糊查询解读：a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描b）%开头的模糊查询，会导致全表扫描禁止大表使用JOIN查询，禁止大表使用子查询解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能禁止使用OR条件，必须改为IN查询解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？应用程序必须捕获SQL异常，并有相应处理总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。原文链接：https://mp.weixin.qq.com/s/Yjh_fPgrjuhhOZyVtRQ-SA","categories":[{"name":"成长鸡汤","slug":"成长鸡汤","permalink":"https://www.elonchung.cn/categories/成长鸡汤/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.elonchung.cn/tags/数据库/"}]},{"title":"Git 命令清单 (补充)","slug":"git-command","date":"2016-08-15T08:54:28.000Z","updated":"2018-05-16T03:14:36.034Z","comments":true,"path":"2016/08/git-command/","link":"","permalink":"https://www.elonchung.cn/2016/08/git-command/","excerpt":"","text":"我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。* Workspace：工作区 * Index / Stage：暂存区 * Repository：仓库区（或本地仓库） * Remote：远程仓库 新建代码库在当前目录新建一个Git代码库$ git init新建一个目录，将其初始化为Git代码库$ git init [project-name]下载一个项目和它的整个代码历史$ git clone [url]配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。显示当前的Git配置$ git config –list编辑Git配置文件$ git config -e [–global]设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]”增加/删除文件添加指定文件到暂存区$ git add [file1] [file2] …添加指定目录到暂存区，包括子目录$ git add [dir]添加当前目录的所有文件到暂存区$ git add .删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] …停止追踪指定文件，但该文件会保留在工作区$ git rm –cached [file]改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]代码提交提交暂存区到仓库区$ git commit -m [message]提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message]提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a提交时显示所有diff信息$ git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit –amend -m [message]重做上一次commit，并包括指定文件的新变化$ git commit –amend [file1] [file2] …分支列出所有本地分支$ git branch列出所有远程分支$ git branch -r列出所有本地分支和远程分支$ git branch -a新建一个分支，但依然停留在当前分支$ git branch [branch-name]新建一个分支，并切换到该分支$ git checkout -b [branch]新建一个分支，指向指定commit$ git branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系$ git branch –track [branch] [remote-branch]切换到指定分支，并更新工作区$ git checkout [branch-name]建立追踪关系，在现有分支与指定的远程分支之间$ git branch –set-upstream [branch] [remote-branch]合并指定分支到当前分支$ git merge [branch]选择一个commit，合并进当前分支$ git cherry-pick [commit]删除分支$ git branch -d [branch-name]删除远程分支$ git push origin –delete [branch-name]$ git branch -dr [remote/branch]标签列出所有tag$ git tag新建一个tag在当前commit$ git tag [tag]新建一个tag在指定commit$ git tag [tag] [commit]查看tag信息$ git show [tag]提交指定tag$ git push [remote] [tag]提交所有tag$ git push [remote] –tags新建一个分支，指向某个tag$ git checkout -b [branch] [tag]查看信息显示有变更的文件$ git status显示当前分支的版本历史$ git log显示commit历史，以及每次commit发生变更的文件$ git log –stat显示某个文件的版本历史，包括文件改名$ git log –follow [file]$ git whatchanged [file]显示指定文件相关的每一次diff$ git log -p [file]显示指定文件是什么人在什么时间修改过$ git blame [file]显示暂存区和工作区的差异$ git diff显示暂存区和上一个commit的差异$ git diff –cached [file]显示工作区与当前分支最新commit之间的差异$ git diff HEAD显示两次提交之间的差异$ git diff [first-branch]…[second-branch]显示某次提交的元数据和内容变化$ git show [commit]显示某次提交发生变化的文件$ git show –name-only [commit]显示某次提交时，某个文件的内容$ git show [commit]:[filename]显示当前分支的最近几次提交$ git reflog远程同步下载远程仓库的所有变动$ git fetch [remote]显示所有远程仓库$ git remote -v显示某个远程仓库的信息$ git remote show [remote]增加一个新的远程仓库，并命名$ git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]上传本地指定分支到远程仓库$ git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突$ git push [remote] –force推送所有分支到远程仓库$ git push [remote] –all撤销恢复暂存区的指定文件到工作区$ git checkout [file]恢复某个commit的指定文件到工作区$ git checkout [commit] [file]恢复上一个commit的所有文件到工作区$ git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]重置暂存区与工作区，与上一次commit保持一致$ git reset –hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset –keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]其他生成一个可供发布的压缩包$ git archive工作中常用到的方法 （补充部分）一、 创建与合并分支1、 从master分支创建dev分支并切换到dev分支：git checkout mastergit checkout -b dev其中，git checkout -b dev 等价于：git branch devgit checkout dev查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支：git branch查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在：git branch-a2、修改代码、提交代码（当前的操作是在dev分支上进行）git add a.htmlgit commit -m “提交文件a.html”3、分支合并(将dev合并到master)git checkout mastergit merge dev4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)git branch -d dev5、删除后，查看分支(此时看不到dev分支了)git branch6、总结 ：工作中经常从master创建新的分支，具体操作如下：git checkout mastergit checkout -b issues1234git push origin issues1234git add ..git commit -m “***”git push origin issues1234注意：将本地分支branch1推到远端的branch2操作步骤：git push origin branch1:branch27、删除分支git git branch -D issues1234 //本地强制删除分支issues1234git push origin:issues1234 //推到远程二、 解决冲突1、发生冲突的文件&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.>&gt;&gt;&gt;&gt;&gt;&gt; feature1其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。如果保留自己的代码，将别人的代码删掉即可。2、冲突解决后提交git statusgit add ***git commit -m “fix conflict”git push origin 分支名三、Bug分支1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用git stash2、恢复储藏的代码git stash pop //恢复的同时把stash内容删掉或者git stash apply//恢复stash，但是stash内容并不删除git stash drop //在上面操作的基础上，以此来删除stash注： git stash list //查看全部的stash列表。3、将stash空间清空git stash clear4、git stash pop 和 git stash apply 区别原来git stash pop stash@{id}命令会在执行后将对应的stash id 从stash list里删除，而 git stash apply stash@{id} 命令则会继续保存stash id。四、版本回退1、回退至上一个版本git reset –hard HEAD2、回退至指定版本git reset –hard 版本号3、查看以往版本号(本地的commit)git reflog4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)git log五、撤销修改1、撤销修改git checkout – a.html分两种情况分析：还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。六、对于已经push的版本，进行回退1、第一步：git reset –hard 版本号 //本地回退到指定的版本2、第二步：git push-f origin dev //将远程的也回退到指定版本七、本地同步远程删除的分支git fetch origin -p //用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了八、删除掉没有与远程分支对应的本地分支从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：git fetch -p九、查看远程库的一些信息，及与本地分支的信息git remote show origin十、git stash临时保存本地操作1、使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的。2、再切换到别的分支改紧急bug。3、改完后，切到刚才的分支，使用git stash apply将以前一半的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用git stash命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，git stash list命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用git stash apply stash@{1}就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用git stash clear来将栈清空。在这里顺便提下git format-patch-n, n是具体某个数字， 例如git format-patch-1这时便会根据log生成一个对应的补丁，如果git format-patch-2那么便会生成2个补丁，当然前提是你的log上有至少有两个记录。","categories":[{"name":"Git","slug":"Git","permalink":"https://www.elonchung.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.elonchung.cn/tags/Git/"}]},{"title":"Thinkphp 的初体验","slug":"thinkphp","date":"2016-08-15T08:54:28.000Z","updated":"2018-05-05T04:48:19.595Z","comments":true,"path":"2016/08/thinkphp/","link":"","permalink":"https://www.elonchung.cn/2016/08/thinkphp/","excerpt":"","text":"使用版本thinkphp3.2查看运行源码入口文件（多个应用index.php） -&gt; 公共入口文件(全站共用ThinkPHP.php)（定义常量）Thinkphp引导类文件（项目初始化、include核心文件、相关配置、调试配置、中间件、驱动配置等）App.class.php 执行应用程序（相当于路由，转发到Controller/action等操作）MVC操作执行了解目录结构Application/ 应用目录包含一套MVC目录、自定义全局函数、配置目录等ThinkPHP/Runtime/ 系统运行时目录Runtime/Logs/ 应用日志目录 Runtime/Temp/ 应用缓存目录 Runtime/Data/ 应用数据目录 Runtime/Cache/ 应用模板缓存目录 Library/ 系统核心类库目录Library/Think/ Think类库目录 Library/Behavior/ 行为类库目录 Library/Vendor/ 第三方类库目录 Common/ 应用公共目录、全局函数Conf/ 应用配置目录Lang/ 应用语言目录Tpl/ 应用静态目录Mode/ 系统应用模式目录index.php 入口文件了解MVC架构Controller 接收用户请求、与Model交互、转发给View数据Model 响应C操作数据库View 接收C的数据并回显给用户信息了解全局函数使用Thinkphp.class.php 引导类中做相应的加载。全局函数项目公共函数自定义函数了解运行的核心文件开启应用模式后会生成~runtime.php 将核心文件的内容编译到一个文件中。不用每次都遍历引入核心文件，提高二次加载的效率了解驱动使用以配置方式加载不同驱动。例如：数据库支持mysql、sqlite、oracle等session 支持memcache/DB/mysqli等优点：上手容易，了解目录结构基本知道其运行流程及原理。整合好一堆SDK ，第三方扩张，轻量级，快速开发。难点：就是要记一堆的全局函数的使用。耦合性比较高。不太支持平滑升级版本。基本上要重写应用。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.elonchung.cn/tags/PHP/"}]},{"title":"Postman模拟登录调试","slug":"postman","date":"2016-03-20T02:38:56.000Z","updated":"2018-05-05T04:46:12.650Z","comments":true,"path":"2016/03/postman/","link":"","permalink":"https://www.elonchung.cn/2016/03/postman/","excerpt":"","text":"postman模拟登录调试postman 算是一个神器了，对于后台开发来说简直就是福音。因为可以直接模拟表单，查看数据等。postman入门使用首先请chrome商店下载postman，选择应用中的postman，拓展程序中的postman interceptor也可以一并安装，这个是为了让我们能够模拟登录用的插件。chrome postman下载地址1.了解postman你可以选择各种请求方式。这里我选的是post。2. 构造请求表单如下图，在body标签中，选择form-data，然后构造了一个有四个请求参数的表单。然后点击send就能够请求和返回后台了。postman模拟登录请求1. chrome打开postman interceptorchrome中打开request capture，Filter requests默认是全部都抓取，你可以自定义。如：localhost:8081表示只拦截本地的8081端口的请求。默认的配置.*配置拦截所有请求，可以使用默认配置不用修改。2. 在浏览器中登录需要调试的网站如果你已经的登录了，那么刷新一下网站就好了，主要是让postman interceptor获取到你这个网站的cookie3. 配置postman在Postman中启用Interceptor，如下图：然后你就可以愉快的调试了～","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"}]},{"title":"phpstorm安装与配置","slug":"phpstorm","date":"2016-03-20T02:38:56.000Z","updated":"2018-05-04T06:00:58.765Z","comments":true,"path":"2016/03/phpstorm/","link":"","permalink":"https://www.elonchung.cn/2016/03/phpstorm/","excerpt":"","text":"phpstorm 快捷键优雅使用phpstormxdebug 配置xdebug 配置phpstorm官网PHP WEB APPLICATION 单页面debug调试PHP REMOTE DEBUG 远程项目调试 （整个项目抓取）","categories":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/categories/小公举/"}],"tags":[{"name":"小公举","slug":"小公举","permalink":"https://www.elonchung.cn/tags/小公举/"},{"name":"phpstorm","slug":"phpstorm","permalink":"https://www.elonchung.cn/tags/phpstorm/"}]}]}